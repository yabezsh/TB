#define ClusterWithTrackAna_cxx
//#include "ClusterWithTrackAna_Inputs.h"
#include "ClusterWithTrackAna.h"
#include <TH2.h>
#include <TH3.h>
#include <TStyle.h>
#include <TLatex.h>
#include <TCanvas.h>
#include <iostream>
#include <fstream>
#include <TProfile2D.h>
#include <cstring>
#include <iostream>
#include <string>
#include <sstream>
#include <cstdlib>

#include <TH1D.h>
#include <TMath.h>
#include <TGraph.h>
#include <TGraphErrors.h>
#include <TF1.h>
#include <TGraphErrors.h>
#include <TChain.h>

#include <RooHist.h>
#include <RooRealVar.h>
#include <RooDataHist.h>
#include <RooLandau.h>
#include <RooExponential.h>
#include <RooGaussian.h>
#include <RooAddPdf.h>
#include <RooPlot.h>
#include <RooFFTConvPdf.h>
#include <RooNumConvPdf.h>
#include <TPaveStats.h> 
#include "RooPlot.h"
#include "TMatrixD.h" 



TString NumberToString ( Int_t Number )
  {
     ostringstream ss;
     ss << Number;
     return ss.str();
  }

struct RetVal{
    Double_t MPV;
    Double_t width;
    Double_t sigma;
};

RetVal PrintLandau(TH1D* h,double Center,int MinAdc,int MaxAdc,TString string,bool writeToFile){
  
   RooMsgService::instance().setGlobalKillBelow(RooFit::FATAL);
  //RooMsgService::setSilentMode();
 RooMsgService::instance().setSilentMode(true);
    // --- Observable ---
    RooRealVar mes("mes","ADC",0,500) ;

    // --- Build Landau  PDF ---
    RooRealVar l_mean("MPV","Landau MPV",Center,0,500) ;
    RooRealVar l_width("Width","Landau width",30,-1000,1000.) ;
    RooLandau landau("landau","landau PDF",mes,l_mean,l_width) ;

    // Construct gauss(t,mg,sg) convolution
    RooRealVar mg("mg","Gmean",0) ;
    RooRealVar sg("SigmaG","Gsigma",3,0.001,200) ;
    RooGaussian gauss("gauss","gauss",mes,mg,sg) ;

    mes.setBins(10000,"cache") ;
    RooFFTConvPdf lxg("lxg","landau (X) gauss",mes,landau,gauss) ;
    RooDataHist *data =  new RooDataHist("data","dataset with x",mes,h) ;
    // --- Perform extended ML fit of composite PDF to toy data ---
    lxg.fitTo(*data,RooFit::Range(MinAdc,MaxAdc)) ;
    // --- Plot toy data and composite PDF overlaid ---
    RooPlot* mesframe = mes.frame(RooFit::Title(string)) ;
    data->plotOn(mesframe,RooFit::Name("data")) ;
    lxg.plotOn(mesframe,RooFit::Name("pdf"),RooFit::LineColor(kRed)) ;
    //lxg.paramOn(mesframe,RooFit::Layout(0.58));
    // DRAW
    mesframe->Draw("lsame");
    // RooMsgService::instance().setGlobalKillBelow(RooFit::FATAL);
    RooFitResult* r = lxg.fitTo(*data,RooFit::Range(MinAdc,MaxAdc),"r") ;
    //cout<<endl<<"chi2 = "<<mesframe->chiSquare("pdf","data")<<endl;

    if(!writeToFile){
        std::ofstream MPVvalue(("MPV_"+ m_board + "_" + runplace + "_" + consR +"_"+m_runNumb+"_roofit.txt").Data());
        MPVvalue << "SNR"<< "," << "SNR uncertainty" << "," << "Width" << "," << "Width uncertainty" << endl;
        MPVvalue << l_mean.getVal() << " " << l_mean.getError() << " " << l_width.getVal() << " " << l_width.getError() << endl;
    }
    RetVal langaus = {l_mean.getVal(),l_width.getVal(),sg.getVal()};

    return langaus;

}


RetVal lFit(TH1D* h,bool MPVreturn = 0,float left=0.45,float right=4.0,TString string = "SNR"){
      Int_t max = 0, maxBin = 0;
      for(Int_t i = h->GetNbinsX()/10.;i<h->GetNbinsX();i++)
	{
	 if(h->GetBinContent(i+1)>max)
	 {
	   max =  h->GetBinContent(i+1);
	   maxBin = i+1;
	 }
	}
    if (MPVreturn==1){
        RetVal MPV = PrintLandau(h,h->GetBinCenter(maxBin),h->GetBinCenter(maxBin)*left,h->GetBinCenter(maxBin)*right,string,1);
        return MPV;  
    }else{ 
              PrintLandau(h,h->GetBinCenter(maxBin),h->GetBinCenter(maxBin)*left,h->GetBinCenter(maxBin)*right,string,0);
	      return {0,0,0};
    }
}

Double_t langaufun(Double_t *x, Double_t *par) {

    //Fit parameters:
    //par[0]=Width (scale) parameter of Landau density
    //par[1]=Most Probable (MP, location) parameter of Landau density
    //par[2]=Total area (integral -inf to inf, normalization constant)
    //par[3]=Width (sigma) of convoluted Gaussian function
    //
    //In the Landau distribution (represented by the CERNLIB approximation),
    //the maximum is located at x=-0.22278298 with the location parameter=0.
    //This shift is corrected within this function, so that the actual
    //maximum is identical to the MP parameter.

    // Numeric constants
    Double_t invsq2pi = 0.3989422804014;   // (2 pi)^(-1/2)
    Double_t mpshift  = -0.22278298;       // Landau maximum location

    // Control constants
    Double_t np = 100.0;      // number of convolution steps
    Double_t sc =   5.0;      // convolution extends to +-sc Gaussian sigmas

    // Variables
    Double_t xx;
    Double_t mpc;
    Double_t fland;
    Double_t sum = 0.0;
    Double_t xlow,xupp;
    Double_t step;
    Double_t i;


    // MP shift correction
    mpc = par[1] - mpshift * par[0];

    // Range of convolution integral
    xlow = x[0] - sc * par[3];
    xupp = x[0] + sc * par[3];

    step = (xupp-xlow) / np;

    // Convolution integral of Landau and Gaussian by sum
    for(i=1.0; i<=np/2; i++) {
        xx = xlow + (i-.5) * step;
        fland = TMath::Landau(xx,mpc,par[0]) / par[0];
        sum += fland * TMath::Gaus(x[0],xx,par[3]);

        xx = xupp - (i-.5) * step;
        fland = TMath::Landau(xx,mpc,par[0]) / par[0];
        sum += fland * TMath::Gaus(x[0],xx,par[3]);
    }

    return (par[2] * step * sum * invsq2pi / par[3]);
}



TF1 *langaufit(TH1F *his, Double_t *fitrange, Double_t *startvalues, Double_t *parlimitslo, Double_t *parlimitshi, Double_t *fitparams, Double_t *fiterrors, Double_t *ChiSqr, Int_t *NDF)
{
    // Once again, here are the Landau * Gaussian parameters:
    //   par[0]=Width (scale) parameter of Landau density
    //   par[1]=Most Probable (MP, location) parameter of Landau density
    //   par[2]=Total area (integral -inf to inf, normalization constant)
    //   par[3]=Width (sigma) of convoluted Gaussian function
    //
    // Variables for langaufit call:
    //   his             histogram to fit
    //   fitrange[2]     lo and hi boundaries of fit range
    //   startvalues[4]  reasonable start values for the fit
    //   parlimitslo[4]  lower parameter limits
    //   parlimitshi[4]  upper parameter limits
    //   fitparams[4]    returns the final fit parameters
    //   fiterrors[4]    returns the final fit errors
    //   ChiSqr          returns the chi square
    //   NDF             returns ndf

    Int_t i;
    Char_t FunName[100];

    sprintf(FunName,"Fitfcn_%s",his->GetName());

    TF1 *ffitold = (TF1*)gROOT->GetListOfFunctions()->FindObject(FunName);
    if (ffitold) delete ffitold;

    TF1 *ffit = new TF1(FunName,langaufun,fitrange[0],fitrange[1],4);
    ffit->SetParameters(startvalues);
    ffit->SetParNames("Width","MP","Area","GSigma");

    for (i=0; i<4; i++) {
        ffit->SetParLimits(i, parlimitslo[i], parlimitshi[i]);
    }

    his->Fit(FunName,"RB0");   // fit within specified range, use ParLimits, do not plot

    ffit->GetParameters(fitparams);    // obtain fit parameters
    for (i=0; i<4; i++) {
        fiterrors[i] = ffit->GetParError(i);     // obtain fit parameter errors
    }
    ChiSqr[0] = ffit->GetChisquare();  // obtain chi^2
    NDF[0] = ffit->GetNDF();           // obtain ndf

    return (ffit);              // return fit function

}


Int_t langaupro(Double_t *params, Double_t &maxx, Double_t &FWHM) {

    // Seaches for the location (x value) at the maximum of the
    // Landau-Gaussian convolute and its full width at half-maximum.
    //
    // The search is probably not very efficient, but it's a first try.

    Double_t p,x,fy,fxr,fxl;
    Double_t step;
    Double_t l,lold;
    Int_t i = 0;
    Int_t MAXCALLS = 10000;


    // Search for maximum

    p = params[1] - 0.1 * params[0];
    step = 0.05 * params[0];
    lold = -2.0;
    l    = -1.0;


    while ( (l != lold) && (i < MAXCALLS) ) {
        i++;

        lold = l;
        x = p + step;
        l = langaufun(&x,params);

        if (l < lold)
            step = -step/10;

        p += step;
    }

    if (i == MAXCALLS)
        return (-1);

    maxx = x;

    fy = l/2;


    // Search for right x location of fy

    p = maxx + params[0];
    step = params[0];
    lold = -2.0;
    l    = -1e300;
    i    = 0;


    while ( (l != lold) && (i < MAXCALLS) ) {
        i++;

        lold = l;
        x = p + step;
        l = TMath::Abs(langaufun(&x,params) - fy);

        if (l > lold)
            step = -step/10;

        p += step;
    }

    if (i == MAXCALLS)
        return (-2);

    fxr = x;


    // Search for left x location of fy

    p = maxx - 0.5 * params[0];
    step = -params[0];
    lold = -2.0;
    l    = -1e300;
    i    = 0;

    while ( (l != lold) && (i < MAXCALLS) ) {
        i++;

        lold = l;
        x = p + step;
        l = TMath::Abs(langaufun(&x,params) - fy);

        if (l > lold)
            step = -step/10;

        p += step;
    }

    if (i == MAXCALLS)
        return (-3);


    fxl = x;

    FWHM = fxr - fxl;
    return (0);
}

void langaus(TH1F *hSNR) {

    TString m_board2 = m_board;
    m_board2 = m_board2.ReplaceAll("_All","");
    m_board2 = m_board2.ReplaceAll("_Full","");
    m_board2 = m_board2.ReplaceAll("_v7","");
    std::ofstream MPVvalue(("MPV_"+ m_board2 + "_" + runplace + "_" + consR +"_"+m_runNumb+".txt").Data());
    // Fill Histogram

    // Fitting SNR histo
    printf("Fitting...\n");

    // Setting fit range and start values
    Double_t fr[2];
    Double_t sv[4], pllo[4], plhi[4], fp[4], fpe[4];
    fr[0]=0.5*hSNR->GetMean();
    fr[1]=2.0*hSNR->GetMean();

    //fr[0]=130;
    //fr[1]=500;

    pllo[0]=0.5; pllo[1]=0.5*hSNR->GetMean(); pllo[2]=1.0; pllo[3]=0.4;
    plhi[0]=100.0; plhi[1]=3*hSNR->GetMean(); plhi[2]=1000000.0; plhi[3]=50.0;
    sv[0]=1.8; sv[1]=hSNR->GetMean(); sv[2]=50000.0; sv[3]=3.0;

    Double_t chisqr;
    Int_t    ndf;
    TF1 *fitsnr = langaufit(hSNR,fr,sv,pllo,plhi,fp,fpe,&chisqr,&ndf);

    //   TPaveStats* st = (TPaveStats*)hSNR->GetListOfFunctions()->FindObject("stats");
    //   st->SetOptStat(1111);


    Double_t SNRPeak, SNRFWHM;
    langaupro(fp,SNRPeak,SNRFWHM);

    printf("Fitting done\nPlotting results...\n");

    // Global style settings
    //gStyle->SetOptStat(111);
    gStyle->SetOptStat(0);
    // gStyle->SetOptFit(111);
    gStyle->SetOptFit(0);
    gStyle->SetLabelSize(0.03,"x");
    gStyle->SetLabelSize(0.03,"y");
    gStyle->SetTitleStyle(0); 
    //TPaveStats *ptstats = new TPaveStats(0.6109302,0.2930544,0.9748452,0.8120352,"brNDC");
    gStyle->SetStatFontSize(0.1);
    //gStyle->SetOptFit()
    //hSNR->GetXaxis()->SetRange(0,70);
    hSNR->GetXaxis()->SetTitle("SNR");
    //hSNR->GetYaxis()->SetTitle("Entries");
    hSNR->SetMaximum(1.5*hSNR->GetMaximum());
    hSNR->Draw();
    fitsnr->Draw("lsame");

    MPVvalue << "SNR"<< "," << "error" << endl;
    MPVvalue << fitsnr->GetParameter(1) << "," << fitsnr->GetParameter(0) << endl;

}


void addGraphics(TH1 *h, int iCol = 1, TString XTitle="", TString YTitle="")
{
    h->SetXTitle(XTitle);
    h->SetYTitle(YTitle);
    h->SetStats(kFALSE);
    h->SetLineColor(iCol);
    h->SetMarkerColor(iCol);
    h->SetMinimum(0.0);
    h->SetMaximum(1.2*h->GetMaximum());
    h->SetTitleSize(0.1);

    //h->SetLineColor(kBlack);
    h->SetMarkerSize(0.7);
    h->SetMarkerStyle(20);
    h->GetXaxis()->SetTitleOffset(1.0);  
    h->GetYaxis()->SetTitleOffset(1.2);
    h->GetXaxis()->SetTitleSize(0.045);  
    h->GetYaxis()->SetTitleSize(0.045);
    h->GetXaxis()->SetLabelSize(0.04);  
    h->GetYaxis()->SetLabelSize(0.04);  
    h->SetNdivisions(505,"X");
    h->SetNdivisions(505,"Y");
    h->SetLineWidth(2);
}

void addGraphics(TH2 *h, int iCol = 1, TString XTitle="", TString YTitle="")
{
    //float bw = h->GetBinWidth(1);
    h->SetXTitle(XTitle);
    h->SetYTitle(YTitle);
    h->SetStats(kFALSE);
    h->SetLineColor(iCol);
    h->SetMarkerColor(iCol);
    h->SetMinimum(0.0);
    h->SetMaximum(1.2*h->GetMaximum());
    h->SetTitleSize(0.1);

    //h->SetLineColor(kBlack);
    //h->SetMarkerSize(0.7);
    //h->SetMarkerStyle(20);
    h->GetXaxis()->SetTitleOffset(1.0);  
    h->GetYaxis()->SetTitleOffset(1.4);
    h->GetXaxis()->SetTitleSize(0.045);  
    h->GetYaxis()->SetTitleSize(0.045);
    h->GetXaxis()->SetLabelSize(0.04);  
    h->GetYaxis()->SetLabelSize(0.04);  
    h->SetNdivisions(505,"X");
    h->SetNdivisions(505,"Y");
    h->SetLineWidth(2);
}

void addGraphics(TH1 *h, TString XTitle, TString YTitle, TString Title="",int iCol = 1)
{
    if (Title!=""){h->SetTitle(Title+": "+ m_board + "," + runplace);}
    h->SetXTitle(XTitle);
    h->SetYTitle(YTitle);
    h->SetStats(kFALSE);
    h->SetLineColor(iCol);
    h->SetMarkerColor(iCol);
    h->SetMinimum(0.0);
    h->SetMaximum(1.2*h->GetMaximum());
    h->SetTitleSize(0.1);

    //h->SetLineColor(kBlack);
    h->SetMarkerSize(0.7);
    h->SetMarkerStyle(20);
    h->GetXaxis()->SetTitleOffset(1.0);  
    h->GetYaxis()->SetTitleOffset(1.4);
    
    h->GetXaxis()->SetTitleSize(0.045);  
    h->GetYaxis()->SetTitleSize(0.045);
    h->GetXaxis()->SetLabelSize(0.04);  
    h->GetYaxis()->SetLabelSize(0.04);  
    
    h->SetNdivisions(505,"X");
    h->SetNdivisions(505,"Y");
    h->SetLineWidth(2);
}
void addGraphics(TH2 *h, TString XTitle, TString YTitle, TString ZTitle, TString Title="",int iCol = 1)
{
    //float bw = h->GetBinWidth(1);
    if (Title!=""){h->SetTitle(Title+": "+ m_board + "," + runplace);}
    h->SetXTitle(XTitle);
    h->SetYTitle(YTitle);
    h->SetZTitle(ZTitle);
    h->SetStats(kFALSE);
    h->SetLineColor(iCol);
    h->SetMarkerColor(iCol);
    h->SetMinimum(0.0);
    h->SetMaximum(1.2*h->GetMaximum());
    h->SetTitleSize(0.1);

    //h->SetLineColor(kBlack);
    //h->SetMarkerSize(0.7);
    //h->SetMarkerStyle(20);
    h->GetXaxis()->SetTitleOffset(1.0);  
    h->GetYaxis()->SetTitleOffset(1.4);
    h->GetZaxis()->SetTitleOffset(1.4);    
    h->GetXaxis()->SetTitleSize(0.045);  
    h->GetYaxis()->SetTitleSize(0.045);
    h->GetZaxis()->SetTitleSize(0.045);
    h->GetXaxis()->SetLabelSize(0.04);  
    h->GetYaxis()->SetLabelSize(0.04);  
    h->GetZaxis()->SetLabelSize(0.04); 
    h->SetNdivisions(505,"X");
    h->SetNdivisions(505,"Y");
    h->SetLineWidth(2);
}

void addGraphics(TGraphErrors *h, TString XTitle, TString YTitle, TString Title="",int iCol = 1)
{
    if (Title!=""){h->SetTitle(Title+": "+ m_board + "," + runplace);}
    h->GetXaxis()->SetTitle(XTitle);
    h->GetYaxis()->SetTitle(YTitle);
    h->SetLineColor(iCol);
    h->SetMarkerColor(iCol);
//    h->SetMinimum(-1.);
//    h->SetMaximum(1.2*h->GetMaximum());

    //h->SetLineColor(kBlack);
    h->SetMarkerSize(0.7);
    h->SetMarkerStyle(20);
    h->GetXaxis()->SetTitleOffset(1.0);  
    h->GetYaxis()->SetTitleOffset(1.2);
    
    h->GetXaxis()->SetTitleSize(0.045);  
    h->GetYaxis()->SetTitleSize(0.045);
    h->GetXaxis()->SetLabelSize(0.04);  
    h->GetYaxis()->SetLabelSize(0.04);  

    h->SetLineWidth(2);
}

TCanvas* addCanvas(TString canvasTitle, Int_t xSize=800, Int_t ySize=800,Double_t rMargin=0.17,Double_t lMargin=0.12)
{

   TCanvas *tempCanvas = new TCanvas(canvasTitle, "",xSize,ySize);
   tempCanvas->SetRightMargin(rMargin);
   tempCanvas->SetLeftMargin(lMargin);
   tempCanvas->cd();
   return tempCanvas;
}

void savePlots(TCanvas* saveCanvas, TString nameFile, TString addFolder = "")
{
  if(addFolder!=""){
    const int dir_err = system("mkdir -p Plots/"+addFolder);
    if (-1 == dir_err)
    {
      printf("Error creating directory!n");
      exit(1);
    }
    addFolder = addFolder+"/";
  }
   // if (nameFile=="Signal_MPV_perStrip"||nameFile=="SNR_MPV_perStrip"){
//if (nameFile=="EffDistrP"){
   saveCanvas->Print("Plots/"+addFolder+nameFile+"_" + m_board + "_" + runplace + "_" + consR +"_"+m_runNumb+".png");
   saveCanvas->Print("Plots/"+addFolder+nameFile+"_" + m_board + "_" + runplace + "_" + consR +"_"+m_runNumb+".pdf");
   saveCanvas->Print("Plots/"+addFolder+nameFile+"_" + m_board + "_" + runplace + "_" + consR +"_"+m_runNumb+".root"); 
   saveCanvas->Print("Plots/"+addFolder+nameFile+"_" + m_board + "_" + runplace + "_" + consR +"_"+m_runNumb+".C"); //}
}

void ClusterWithTrackAna::Loop()
{
//   In a ROOT session, you can do:
//      Root > .L ClusterWithTrackAna.C
//      Root > ClusterWithTrackAna t
//      Root > t.GetEntry(12); // Fill t data members with entry number 12
//      Root > t.Show();       // Show values of entry 12
//      Root > t.Show(16);     // Read and show values of entry 16
//      Root > t.Loop();       // Loop on all entries
//

//     This is the loop skeleton where:
//    jentry is the global entry number in the chain
//    ientry is the entry number in the current Tree
//  Note that the argument to GetEntry must be:
//    jentry for TChain::GetEntry
//    ientry for TTree::GetEntry and TBranch::GetEntry
//
//       To read only selected branches, Insert statements like:
// METHOD1:
//    fChain->SetBranchStatus("*",0);  // disable all branches
//    fChain->SetBranchStatus("branchname",1);  // activate branchname
// METHOD2: replace line
//    fChain->GetEntry(jentry);       //read all branches
//by  b_branchname->GetEntry(ientry); //read only this branch
   if (fChain == 0) return;

   Int_t nentries = fChain->GetEntriesFast();

   //if(nentries%1000) cout << "entry is " << nentries << endl;

   TString m_board2 = m_board;
   m_board2 = m_board2.ReplaceAll("_All","");
   m_board2 = m_board2.ReplaceAll("_Full","");
   m_board2 = m_board2.ReplaceAll("_v7","");
   TString f_out = m_fileOutdir + plotdir + "/AnalysisOutput_" + m_board2 + "_" + runplace + "_" + consR +"_"+m_runNumb+".root";

  // TString f_out = m_fileOutdir + plotdir + "/AnalysisOutput_" + m_board2 + "_" + m_bias + "_" + m_sector + ".root";
   if(m_angle != "0"){
     f_out			= m_fileOutdir + plotdir + "/AnalysisOutput_" + m_board2 + "_" + m_bias + "_" + m_sector + "_" + m_angle + ".root";
   }
   cout << "Will write out file: " << f_out << endl;
   


   fout = new TFile(f_out,"RECREATE");

   // cluster charge vs. channel
   // TH2F* h_clst_chan = new TH2F("h_clst_chan","Cluster charge vs. seed channel",

   // eff vs. x and y
   //   TH2F* h_eff_xy = new TH2F("h_eff_xy","Efficiency vs. position",100,-8,8,100,-8,8);

    // channel range
    cout << channel_low << endl;
    cout << channel_hi << endl;
    int chHi = channel_hi+10;
    int chLow= channel_low-10;
    int nbins=chHi-chLow;

   TH1F* h0 = new TH1F("h0","#DeltaX between strip hit and track projection (strips)",80,-20.,20.); // Distribution of the delta x between the position of the cluster and the position of the strip expected based on the track information. Distribution not centered in zero and/or not symmetric if the alignment is not properly done.
   TH1F* h1 = new TH1F("h1","#DeltaX",1600,-4.0,4.0);
   TH2F* h1vsx = new TH2F("h1vsx","#DeltaX vs X",50,-5,5,100,-0.2,0.2);
   TH1F* h1mpa = new TH1F("h1mpa","#DeltaX",400,-20.0,20.0);
   TH1F* h1mbpa = new TH1F("h1mbpa","#DeltaX",400,-20.0,20.0);
   TH1F* h1fpa = new TH1F("h1fpa","#DeltaX",400,-20.0,20.0);
   TH1F* h1fbpa = new TH1F("h1fbpa","#DeltaX",400,-20.0,20.0);

   TH1F* h1mpa1 = new TH1F("h1mpa1","#DeltaX",800,-20.0,20.0);
   TH1F* h1mpa2 = new TH1F("h1mpa2","#DeltaX",800,-20.0,20.0);
   TH1F* h1mpa3 = new TH1F("h1mpa3","#DeltaX",800,-20.0,20.0);
   TH1F* h1mpa4 = new TH1F("h1mpa4","#DeltaX",800,-20.0,20.0);
   TH1F* h1mpa5 = new TH1F("h1mpa5","#DeltaX",800,-20.0,20.0);

   TH1F* h1mpaL = new TH1F("h1mpaL","Strip# of Missed Hit in Lower PA region",512,0,512);
   TH1F* h1mpaU = new TH1F("h1mpaU","Strip# of Missed Hit in Upper PA region",512,0,512);


   TH1F* h1s = new TH1F("h1s","Seed strip of cluster",512,0.0,512.0);
   TH1F* h1a = new TH1F("h1a","#DeltaX, 1 strip",800,-2.0,2.0);
   TH1F* h1b = new TH1F("h1b","#DeltaX, 2 strip",800,-2.0,2.0);
   TH1F* h1z = new TH1F("h1z","#DeltaX, low Charge",800,-2.0,2.0);
   TH1F* h1w = new TH1F("h1w","#DeltaX",20000,-100.0,100.0);
   TH1F* h1wY = new TH1F("h1wY","#DeltaX",20000,-100.0,100.0);
   TH2F* h2 = new TH2F("h2","X_{DUT} vs X_{trk}",100,-3,3,100,-3,3);
   TH2F* h3 = new TH2F("h3","Y_{trk} vs X_{trk}, with cluster",640,-8,8.0,640,-8,8);
   TH2F* h311 = new TH2F("h311","Y_{trk} vs X_{trk}",100,-5,5,100,-6,6);
   TH2F* h311a = new TH2F("h311a","Y_{trk} vs X_{trk}, with cluster",100,-5,5,100,-6,6);
   TH2F* h311b = new TH2F("h311b","Y_{trk} vs X_{trk}",100,-5,5,100,-6,6);
   // TH2F* h3a = new TH2F("h3a","Y_{trk} vs X_{trk} in fiducial",640,-8,8.0,640,-8,8);
   // TH2F* h3b = new TH2F("h3b","Y_{trk} vs X_{trk}, with missed cluster",640,-8,8.0,640,-8,8);
   // TH2F* h3c = new TH2F("h3c","Y_{trk} vs X_{trk}, with found cluster",640,-8,8.0,640,-8,8);
   TH2F* h3a = new TH2F("h3a","Y_{trk} vs X_{trk} in fiducial",32,-3.6,3.6,32,-4,4);
   TH2F* h3b = new TH2F("h3b","Y_{trk} vs X_{trk}, with missed cluster",160,-4,4.0,160,-4,4);
   TH2F* h3c = new TH2F("h3c","Y_{trk} vs X_{trk}, with found cluster",32,-3.6,3.6,32,-4,4);
   TH1F* h4 = new TH1F("h4","Detector strip # of cluster with track",512,0.0,512);
   TH1F* h4a = new TH1F("h4a","Electonic Strip # of cluster with track",512,0.0,512);
   TH1F* h4b = new TH1F("h4b","Strip # of cluster with track",1024,0.0,1024);
   TH1F* h4c = new TH1F("h4c","Strip # of cluster with track",1024,0.0,1024);
   TH1F* h5 = new TH1F("h5","#theta_{X}",500,-5.0,5.0);
   TH1F* h6 = new TH1F("h6","#theta_{Y}",500,-5.0,5.0);
   TH1F* h5c = new TH1F("h5c","#theta_{X}",500,-5.0,5.0);
   TH1F* h6c = new TH1F("h6c","#theta_{Y}",500,-5.0,5.0);
   TH1F* h5a = new TH1F("h5a","X position of track",400,-10.0,10.0);
   TH1F* h6a = new TH1F("h6a","Y position of track",25,-5.0,5.0);
   TH1F* h5b = new TH1F("h5b","X position of matched cluster",400,-10.0,10.0);
   TH1F* h6b = new TH1F("h6b","Y position of matched cluster",400,-10.0,10.0);
   TH1F* h6d = new TH1F("h6d","Y position of matched cluster",400,-10.0,10.0);

   TProfile *h8 = new TProfile("h8","#DeltaX vs #theta_{trk}",50,-5,5,-1.0,1.0);
   TProfile *h8b = new TProfile("h8","#DeltaX vs #theta_{trk}",50,-5,5,-1.0,1.0);
   TProfile *h9 = new TProfile("h9","#DeltaX vs Y_{trk} at DUT",25,-6,6,-1.0,1.0);
   TProfile *h9a = new TProfile("h9a","#DeltaX vs X_{trk} at DUT",25,-6,6,-1.0,1.0);

   TProfile *h10a = new TProfile("h10a","<ADC> vs strip",512,0,512,0.0,1000.0);
   TProfile *h10b = new TProfile("h10b","<ADC> vs strip",512,0,512,0.0,1000.0);
   TProfile *h10c = new TProfile("h10c","<ADC> vs strip",512,0,512,0.0,1000.0);
   TProfile *h10d = new TProfile("h10d","<ADC> vs Y_{trk}",100,-8,8,0.0,1000.0);
   TProfile *h10e = new TProfile("h10e","<ADC> vs X_{trk}",100,-8,8,0.0,1000.0);
   TH1F* h11n = new TH1F("h11n","Strip # of matched cluster",512,0.0,512);
   TH1F* h11d = new TH1F("h11d","Strip # of track",512,0.0,512);
   h11n->Sumw2();
   h11d->Sumw2();
   
   TH1F* h12 = new TH1F("h12","Y position of matched cluster",400,-10.0,10.0); h12->Sumw2();
   TH1F* h122 = new TH1F("h122","Y position of matched cluster",15,-7.0,7.0); h12->Sumw2();
   TH1F* h123 = new TH1F("h123","y position of matched cluster",15,-7.0,7.0); h12->Sumw2();
   TH1F* h12c = new TH1F("h12c","X position of matched cluster",400,-10.0,10.0);h12c->Sumw2();
   TH1F* h12a = new TH1F("h12a","Y position of track",1000,-6.0,6.0); h12a->Sumw2();
   TH1F* h12b = new TH1F("h12b","Y position of track",1000,-6.0,6.0); h12b->Sumw2();

   // ADDED BY CHRIS 24.06.2016 -------------
   // 1D Efficiency plots
   TH1F* hEffX = new TH1F("hEffX","X position of track,",100,-5,5);
   TH1F* hEffY = new TH1F("hEffY","Y position of track,",100,-6,6);

   // 1D trk plots (also used for efficiency calc)
   TH1F* hTrkX = new TH1F("hTrkX","X position of track [mm]",100,-5,5);
   TH1F* hTrkY = new TH1F("hTrkY","Y position of track [mm],",100,-6,6);

   // ---------------------------------------
   TH1F* h12dn = new TH1F("h12dn","X position of track",200,-10.0,10.0); h12dn->Sumw2();
   TH1F* h12en = new TH1F("h12en","X position of track",200,-10.0,10.0);h12en->Sumw2();
   TH1F* h12fn = new TH1F("h12fn","X position of track",200,-10.0,10.0);h12fn->Sumw2();
   TH1F* h12gn = new TH1F("h12gn","X position of track",200,-10.0,10.0);h12gn->Sumw2();
   TH1F* h12dd = new TH1F("h12dd","X position of track",200,-10.0,10.0);h12dd->Sumw2();
   TH1F* h12ed = new TH1F("h12ed","X position of track",200,-10.0,10.0);h12ed->Sumw2();
   TH1F* h12fd = new TH1F("h12fd","X position of track",200,-10.0,10.0);h12fd->Sumw2();
   TH1F* h12gd = new TH1F("h12gd","X position of track",200,-10.0,10.0);h12gd->Sumw2();

   TH1F* h12hn = new TH1F("h12hn","X position of track",50,-0.5,0.5);h12hn->Sumw2();
   TH1F* h12in = new TH1F("h12in","X position of track",50,-0.5,0.5);h12in->Sumw2();
   TH1F* h12jn = new TH1F("h12jn","X position of track",50,-0.5,0.5);h12jn->Sumw2();
   TH1F* h12kn = new TH1F("h12kn","X position of track",50,-0.5,0.5);h12kn->Sumw2();
   TH1F* h12hd = new TH1F("h12hd","X position of track",50,-0.5,0.5);h12hd->Sumw2();
   TH1F* h12id = new TH1F("h12id","X position of track",50,-0.5,0.5);h12id->Sumw2();
   TH1F* h12jd = new TH1F("h12jd","X position of track",50,-0.5,0.5);h12jd->Sumw2();
   TH1F* h12kd = new TH1F("h12kd","X position of track",50,-0.5,0.5);h12kd->Sumw2();

   TProfile *h12m = new TProfile("h12m","<ADC> vs interstrip pos",50,-0.5,0.5,0.0,1000.0);
   TProfile *h12n = new TProfile("h12n","<ClusterSize> vs interstrip pos",50,-0.5,0.5,0.0,1000.0);
   TProfile *hClusterStrip = new TProfile("hClusterStrip","Cluster Size per strip",512,0,512,0,2);
   TH2F* hAlpha = new TH2F("hAlpha","<SNR(i) / SNR(seed)>", 512,0,512,512,0,512);
   TH2F* hAsym = new TH2F("hAsym", "Charge asymmetry about seed",512,0,512,200,-1,1);
   TH1F* hAsym_av = new TH1F("hAsym_av", "Charge asymmetry about seed",200,-1,1);
   TH2F *hEta = new TH2F("hEta","Eta vs. strip",512,0,512,200,-1,1);
   TH2F *hEta_dX = new TH2F("hEta_dX","Eta vs. #Delta x",50,0,0.25,200,-1,1);
   TH1D *hEta_proj = new TH1D("hEta_proj","Eta",200,-1,1);
   // hAlpha = hR_SNR->Clone();
   TH1F* h12cc = new TH1F("h12cc","Cluster Size",5,0,5);
   TH1F* h12on = new TH1F("h12on","dist of track to cutout",700,-2.0,5.0);h12on->Sumw2();
   TH1F* h12od = new TH1F("h12od","dist of track to cutout",700,-2.0,5.0);h12od->Sumw2();

   TH1F *h13mpa = new TH1F("h13mpa","#Clusters/Ev",10,-0.5,9.5);
   TH1F *h13mbpa = new TH1F("h13mbpa","#Clusters/Ev",10,-0.5,9.5);
   TH1F *h13fpa = new TH1F("h13fpa","#Clusters/Ev",10,-0.5,9.5);
   TH1F *h13fbpa = new TH1F("h13fbpa","#Clusters/Ev",10,-0.5,9.5);   

   TH1F* h14a = new TH1F("h14a","Nom Strip, no matched cluster",512,0.0,512);
   TH1F* h14b = new TH1F("h14b","Nom Strip, matched cluster",512,0.0,512);

   TH1F *h15a = new TH1F("h15a","Chisq of tracks with matched DUT hit",200,0.0,200.0);
   TH1F *h15b = new TH1F("h15b","TDC time with matched DUT hit",12,0.0,12.0);
   TH1F *h15c = new TH1F("h15c","Time Between Trigger and Track",5,0.0,5.0);
   TH1F *h15d = new TH1F("h15d","TDC time of all clusters",12,0.0,12.0);
   TH1F *h15e = new TH1F("h15e","TDC time of good clusters",12,0.0,12.0);

   TH1F *h16a = new TH1F("h16a","Chisq of tracks without matched DUT hit",200,0.0,200.0);
   TH1F *h16b = new TH1F("h16b","TDC time without matched DUT hit",12,0.0,12.0);
   TH1F *h16c = new TH1F("h16c","Time Between Trigger and Track",5,0.0,5.0);
   h15c->Sumw2();
   h16c->Sumw2();
   
   TH1F* h17 = new TH1F("h17","Q_{L} / (Q_{L}+Q_{R})",50,0.0,1.0);
   TH2F* h17a = new TH2F("h17a","Q_{L} / (Q_{L}+Q_{R}) vs Interstrip Pos",20,-0.5,0.5,120,-0.1,1.1);
   TProfile* h17b = new TProfile("h17b","Q_{R} / (Q_{L}+Q_{R}) vs Interstrip Pos",20,-0.5,0.5,-0.1,1.1);

   TH1F* hcmpa = new TH1F("hcmpa","Cluster charge",100,0.0,1000.0);
   TH1F* hcmbpa = new TH1F("hcmbpa","Cluster charge",100,0.0,1000.0);
   TH1F* hcfpa = new TH1F("hcfpa","Cluster charge",100,0.0,1000.0);
   TH1F* hcfbpa = new TH1F("hcfbpa","Cluster charge",100,0.0,1000.0);

   TH1F* h18a = new TH1F("h18a","Seed/Total charge",100,0.0,2.0);

   TH2F* h18b = new TH2F("h18b","#DeltaX vs Interstrip Pos (1 strip Clu)",100,-0.5,0.5,100,-0.2,0.2);
   TH2F* h18c = new TH2F("h18c","#DeltaX vs Interstrip Pos (2 strip Clu)",100,-0.5,0.5,100,-0.2,0.2);
   TH2F* h18d = new TH2F("h18d","Seed/Total charge vs Interstrip Pos",100,-0.5,0.5,100,0.0,1.1);

   TH1F* hcTrkXY[16];
   for(int i=0; i<4; i++){
     for(int j=0; j<4; j++){
       int iblock = 4*i+j; 
       TString hname = Form("hcTrkXY_%d",iblock+1);     
       TString htitle = Form("Cluster charge, block %d",iblock+1);     
       hcTrkXY[iblock]= new TH1F(hname,htitle,100,0.0,1000.0);
     }
   }
   
   TH2F *hADCperStrip = new TH2F("hADCperStrip","ADC per Strip",512,0,512,500,0,1000);
   TH2F *hSNRperStrip = new TH2F("hSNRperStrip","SNR per Strip",512,0,512,50,0,100);
   TH1F *hlandau[512];
   for(int i=0; i<nChan; i++){
     hlandau[i] = new TH1F(Form("hlandau_%d",i),"Cluster charge",100,0.0,1000.0);
   }
   


   TH1F* hcAll = new TH1F("hcAll","Cluster charge",100,0.0,1000.0);
   TH1F* hcTrk = new TH1F("hcTrk","Cluster charge",100,0.0,1000.0);
   TH1F* hcTrkCorr = new TH1F("hcTrkCorr","Cluster charge",100,0.0,1000.0);
   TH1F* hcTrkSeed = new TH1F("hcTrkSeed","Cluster charge",100,0.0,1000.0);
   TH1F* hcTrkSeed1 = new TH1F("hcTrkSeed1","Cluster charge",100,0.0,1000.0);
   TH1F* hcTrkSeed2 = new TH1F("hcTrkSeed2","Cluster charge",100,0.0,1000.0);
   //TH1F* hcTrkY1 = new TH1F("hcTrkY1","Cluster charge",100,0.0,1000.0);
   //TH1F* hcTrkY2 = new TH1F("hcTrkY2","Cluster charge",100,0.0,1000.0);
   //TH1F* hcTrkY3 = new TH1F("hcTrkY3","Cluster charge",100,0.0,1000.0);
   //TH1F* hcTrkY4 = new TH1F("hcTrkY4","Cluster charge",100,0.0,1000.0);
   TH1F* hcTrkNoTop = new TH1F("hcTrkNoTop","Cluster charge",100,0.0,1000.0);
   TH1F* hcTrkLowX = new TH1F("hcTrkLowX","Cluster charge",100,0.0,1000.0);
   TH1F* hcTrkHighX = new TH1F("hcTrkHighX","Cluster charge",100,0.0,1000.0);
   TH1F* hcTrka = new TH1F("hcTrka","Cluster charge, limited region",100,0.0,1000.0);
   TH1F* hcTrk1 = new TH1F("hcTrk1","Cluster charge, Size = 1",100,0.0,1000.0);
   TH1F* hcTrk2 = new TH1F("hcTrk2","Cluster charge, Size = 2",100,0.0,1000.0);
   TProfile *h2p = new TProfile("h2p","Cluster Charge vs TDC time",12,0,12,100,1000);


   TH2F* h31a = new TH2F("h31a","Y_{trk} vs X_{trk}, with cluster",64,-8,8.0,64,-8,8);
   TH2F* h31b = new TH2F("h31b","Y_{trk} vs X_{trk}, with cluster, low ADC",64,-8,8.0,64,-8,8);
   TH1F* h32a = new TH1F("h32a","Strip # of cluster with track",512,0.0,512);
   TH1F* h32b = new TH1F("h32b","Strip # of cluster with track & low ADC",512,0.0,512);
   TH1F* h33a = new TH1F("h33a","Y position of matched cluster",200,-10.0,10.0);
   TH1F* h33b = new TH1F("h33b","X position of matched cluster",200,-10.0,10.0);
   TH1F* h34 = new TH1F("h34","Y position of matched cluster & low ADC",200,-10.0,10.0);

   TH1F *hnoise = new TH1F("hnoise","Noise in connected channels",100,-200,200);
   TH1F *hnoiseChan = new TH1F("hnoiseChan","Noise in connected channels",200,0,200);
   TH1F *hnoisePerChannel = new TH1F("hnoisePerChannel","Noise",512,0,512);
   TH3F *hSNR = new TH3F("hSNR","SNR",50,-5,5,50,-6,6,50,0,100);
   TH2F *hSNR2D =  new TH2F("hSNR2D","SNR2D",50,-5,5,50,-6,6);
   TH1D *hSNR_1 = new TH1D("hSNR_1","SNR",500,0,100);

   TH1F* h35 = new TH1F("h35","No. clusters / event",50,0.0,50.0);
   
   TH1F *h41[10];
   TH1F *h42[10];
   TH1F *h43[10];
   TH1F *h44[10];
   for(int i=0; i<10; i++){
     h41[i] = new TH1F(Form("h41_%d",i),Form("ADC_{L}-ADC_{R}, Bin %d, Odd Ch",i),80,-400,400);
     h42[i] = new TH1F(Form("h42_%d",i),Form("ADC_{L}-ADC_{R}, Bin %d, Odd Ch",i),80,-400,400);
     h43[i] = new TH1F(Form("h43_%d",i),Form("ADC_{L}-ADC_{R}, Bin %d, Odd Ch",i),160,-400,400);
     h44[i] = new TH1F(Form("h44_%d",i),Form("ADC_{L}-ADC_{R}, Bin %d, Odd Ch",i),160,-400,400);
   }
   

   Double_t maxSeedCharge;
   int maxSeedPos;
   /*Double_t  clustersSeedPosition[10];
   Double_t  clustersSeedCharge[10];
   Double_t  SNR[512];
   TMatrixD alpha(512,512);
   tree->SetBranchAddress("clustersSeedPosition", clustersSeedPosition);
   tree->SetBranchAddress("clustersSeedCharge", clustersSeedCharge);
   tree->SetBranchAddress("SNR",SNR);
*/
 TMatrixD alpha(512,512);
   for(int i=0; i<nChan; i++){
     hnoisePerChannel->Fill(i+0.5,noise[i]);
  }
   


   //------------------------------------------------------------------------------------------------------
   
   //-----------------------------
   // Prepare DUT (Alignment, etc)
   //-----------------------------

   PrepareDUT();
   //return;
   float biasVal = atof(m_bias);
   cout << "chargeCorrSlopeOdd, chargeCorrSlopeEven = " << chargeCorrSlopeOdd << " " << chargeCorrSlopeEven << " " 
        << m_bias << " " << biasVal << endl;
   

   std::ofstream myfile;
   if(writeEventsWithMissinhHitsToFile){
     myfile.open("MissingDUTHits.dat");
   }
  
   int iChan = nChan;
   double nomStrip = 0, detStrip = 0;
   int nPrint = 0;
   double dxh[10];
   int njump = 10000;
   if(nentries > 100000) njump = 50000;
   Long64_t nbytes = 0, nb = 0;
   cout << "Begin loop over " << nentries << " events" << endl;
   for (Long64_t jentry=0; jentry<nentries;jentry++) {
      Long64_t ientry = LoadTree(jentry);
      if (ientry < 0) break;
      nb = fChain->GetEntry(jentry);   nbytes += nb;
      if(jentry%njump==0) cout << "====> At entry = " << jentry << endl;
      if(n_tp3_tracks != 1) continue;

      //==========================================
      // Example here of acccessing CMS strip data
      //==========================================
      if(fCMS){
        for(int k=0;k<iChan;k++){
          if(fCMS->cmsData[k]!=0) hnoise->Fill(fCMS->cmsData[k]);
        }      
      }

      h35->Fill(clusterNumberPerEvent);
      if(clusterNumberPerEvent>10) continue;
      
      
      // Loop over TPIX tracks in event
      for(int k=0; k<n_tp3_tracks; k++){
        if(dtime > trackTriggerTimeDiffCut) continue;
        double x_trk = vec_trk_tx->at(k)*z_DUT+vec_trk_x->at(k);
        double y_trk = vec_trk_ty->at(k)*z_DUT+vec_trk_y->at(k);
        
        transformTrackToDUTFrame(k, x_trk, y_trk, nomStrip, detStrip);

        //if(isInCutoutRegion(x_trk, y_trk)) continue;
        double distToCutout = DistToCutoutRegion(x_trk, y_trk);
        bool awayFromCutout = distToCutout > minDistFromHole;

        int closestStrip = nomStrip;
        double fracStrip = nomStrip - closestStrip - 0.5;

        double tx = 1000*vec_trk_tx->at(k);
        double ty = 1000*vec_trk_ty->at(k);
	
  
  
        h5->Fill(tx);
        h6->Fill(ty);

        // Test cuts here, e.g.  to reject regions
        //if(nomStrip<422 || nomStrip>442) continue;
        //if(y_trk>2.4) continue;
        //if(nomStrip<420 || nomStrip>445) continue;
        
	
        bool goodRegion = true;
        for(int id = 0; id<nDeadRegion; id++){
          if(x_trk>=deadRegionLo[id]  && x_trk<=deadRegionHi[id]) goodRegion = false;  
	}
	if(!goodRegion) continue;
	//h311b->Fill(x_trk,y_trk);
        h5a->Fill(x_trk);
        h6a->Fill(y_trk);
        bool goodTrack = false;
        bool inFiducialX = false;
        bool inFiducialY = false;

        if(x_trk>xMin && x_trk<xMax) inFiducialX = true;          
        if(y_trk>yMin && y_trk<yMax) inFiducialY = true;          
        bool inFiducial = inFiducialX && inFiducialY;
        inFiducial = inFiducial && (x_trk<xLeftHole || x_trk>xRightHole);
        
        if(tx>txMin && tx<txMax && ty>tyMin && ty<tyMax) goodTrack = true;        
        bool goodTime =  (clustersTDC >= tdcLo && clustersTDC <= tdcHi);

	if(goodTrack && goodTime && awayFromCutout) {
	  // 2D tracks
	  h311b->Fill(x_trk,y_trk);
	  //hTrkX->Fill(x_trk);
	  //hTrkY->Fill(y_trk);

	}
        if(goodTrack && goodTime && inFiducial) h12od->Fill(distToCutout);
	
	if(goodTrack && goodTime && awayFromCutout) {
	  hTrkX->Fill(x_trk);
	  hTrkY->Fill(y_trk);
	}
        if(goodTrack && goodTime && inFiducial && awayFromCutout) {
          h3a->Fill(x_trk,y_trk);

          h12a->Fill(y_trk);
          h12dd->Fill(x_trk);
          if(y_trk>yInt1[0]&&y_trk<yInt1[1]) h12ed->Fill(x_trk);
          if(y_trk>yInt2[0]&&y_trk<yInt2[1]) h12fd->Fill(x_trk);
          if(y_trk>yInt3[0]&&y_trk<yInt3[1]) h12gd->Fill(x_trk);
          h12hd->Fill(fracStrip);
          if(y_trk>yInt1[0]&&y_trk<yInt1[1] && x_trk>-3.5&&x_trk<2.5) h12id->Fill(fracStrip);
          if(y_trk>yInt2[0]&&y_trk<yInt2[1] && x_trk>-3.5&&x_trk<2.5) h12jd->Fill(fracStrip);
          if(y_trk>yInt3[0]&&y_trk<yInt3[1] && x_trk>-3.5&&x_trk<2.5) h12kd->Fill(fracStrip);
        }

        bool foundHit = false;
        bool foundHitNoFid = false;
        double x_trk0 = x_trk;
        for(int j=0; j<min(clusterNumberPerEvent,10); j++){
          dxh[j] = -999;
          if(clustersPosition[j] < 0.1) continue;
          if(polarity*clustersCharge[j] < 0.2*kClusterChargeMin) continue;
          double x_dut = getDUTHitPosition(j);
          x_trk = x_trk0;
	  //cout << "x_dut = " << x_dut << endl;


          int iPeak = 1;
          if(clustersSeedPosition[j]%2==0) iPeak = 0;
          
          h1s->Fill(clustersSeedPosition[j]);
          if(clustersSeedPosition[j]<iLo-5 || clustersSeedPosition[j]>iHi+5) continue;

          double dx = x_dut - x_trk;
          dxh[j] = dx;

	  //if(dx<0.2 && )
	  // h122->Fill(y_trk);
	  h123->Fill(y_trk);
          if(inFiducial && goodTime && awayFromCutout) h12->Fill(y_trk); 
          if(goodTrack && inFiducial && fabs(dx)<dxWin && awayFromCutout) {
            h2p->Fill(clustersTDC+0.1,polarity*clustersCharge[j]);
            h15d->Fill(clustersTDC);          
            if(goodTime) h15e->Fill(clustersTDC);          
          }
	  int ichan_1 = clustersSeedPosition[j];
	  Double_t snr = polarity*clustersCharge[j]/noise[ichan_1];
	  
	  if(goodTrack && goodTime && awayFromCutout) {
	    hADCperStrip->Fill(ichan_1,polarity*clustersCharge[j]);
	    hSNRperStrip->Fill(ichan_1,snr);
	    h311->Fill(x_trk,y_trk);
	    hSNR->Fill(y_trk,x_trk,snr);
	    hSNR_1->Fill(snr);
	  }
   // tree->GetEntry(jentry);
     maxSeedCharge=0;
     maxSeedPos=0;
     for (int j=0;j<10;j++){
       if (clustersSeedPosition[j]==0)continue;
       if (maxSeedCharge<clustersSeedCharge[j]){
         maxSeedCharge=clustersSeedCharge[j];
         maxSeedPos=clustersSeedPosition[j];
       }
     }
     
     // ASSUME FOUND MAX -> maxCh
     
     if(goodTrack && goodTime && fabs(dx)<dxWin && awayFromCutout){
       h311a->Fill(x_trk,y_trk);
       //hEffX->Fill(x_trk);
       //hEffY->Fill(y_trk);
       h122->Fill(y_trk);
       if (SNR[maxSeedPos]!=0){
	 for(int m=0;m<512;m++){
	   if(SNR[m]>0) {
	     double old = hAlpha->GetBinContent(maxSeedPos,m);
	     alpha[maxSeedPos][m]=SNR[m]/SNR[maxSeedPos];
	     hAlpha->SetBinContent(maxSeedPos,m,old+alpha[maxSeedPos][m]);
	   }
	 }
       }
       
       // if chanMx=clusterPos
       
     }
     
     if(goodTrack && inFiducial && goodTime && fabs(dx)<dxWin){
       h3->Fill(x_trk,y_trk);
     }
     
     if(goodTrack && inFiducial && goodTime && fabs(dx)<dxWin) foundHitNoFid = true;
     
     
     
     if(goodTrack && inFiducial && goodTime && awayFromCutout) {
       hcAll->Fill(polarity*clustersCharge[j]);
       h2->Fill(x_trk, x_dut);
       h1->Fill(dx);
       if(clustersSize[j]==1) h1a->Fill(dx);
       if(clustersSize[j]==2) h1b->Fill(dx);
       h1w->Fill(dx);
       if(y_trk>2.5) h1wY->Fill(dx);
       if(polarity*clustersCharge[j] < 250) h1z->Fill(dx);
       h11d->Fill(detStrip);        
       
       if(fabs(dx)<dxWin) {
	 int ichan = clustersSeedPosition[j];
	 h4c->Fill(clustersSeedPosition[j]);
	 if(ichan>=0 && ichan<=511){
	   hlandau[ichan]->Fill(polarity*clustersCharge[j]);
	 }
         
	 hnoiseChan->Fill(noise[ichan]);
	 h18a->Fill(clustersSeedCharge[j]/clustersCharge[j]);
	 foundHit = true;
	 if(clustersSize[j]==1) h18b->Fill(fracStrip,dx);
	 if(clustersSize[j]==2) h18c->Fill(fracStrip,dx);
	 h18d->Fill(fracStrip,clustersSeedCharge[j]/clustersCharge[j]);
	 
	 h12m->Fill(fracStrip,polarity*clustersCharge[j]);
	 h12n->Fill(fracStrip,clustersSize[j]);
	 hClusterStrip->Fill(ichan,clustersSize[j]);
	 h12cc->Fill(clustersSize[j]);
	 h1vsx->Fill(x_trk,dx);
	 if(y_trk>yMid&&y_trk<yMax) h10a->Fill(clustersPosition[j],polarity*clustersCharge[j]);
	 if(y_trk>yMin&&y_trk<yMid) h10b->Fill(clustersPosition[j],polarity*clustersCharge[j]);
	 if(y_trk>yHi2&&y_trk<yMax) h10c->Fill(clustersPosition[j],polarity*clustersCharge[j]);
	 h10d->Fill(y_trk,polarity*clustersCharge[j]);
	 h10e->Fill(x_trk,polarity*clustersCharge[j]);
	 double chleft = polarity*clustersCharge1StripLeft[j];
	 double chright = polarity*clustersCharge1StripRight[j];
	 //double asym = (chleft - chright) / (chleft + chright);
	 
	 double rc = -999;
	 if(detStrip <= clustersSeedPosition[j]) {
	   if(chleft>0) rc = (chleft/(chleft+clustersSeedCharge[j]));              
	 }else{ 
	   if(chright>0) rc = (clustersSeedCharge[j]/(chright+clustersSeedCharge[j]));
	 }
	 if( rc>=0 ) {
	   h17->Fill(rc);
	   h17a->Fill(fracStrip,rc);
	   h17b->Fill(fracStrip,rc);
	 }
	 h8->Fill(1000*vec_trk_tx->at(k),dx);
	 h8b->Fill(1000*vec_trk_ty->at(k),dx);
	 h9->Fill(y_trk,dx);
	 h9a->Fill(x_trk,dx);
	 h5b->Fill(x_trk);
	 h6b->Fill(y_trk);
	 h5c->Fill(tx);
	 h6c->Fill(ty);
	 if(abs(dx<0.2)) h6d->Fill(y_trk);
	      
              h11n->Fill(detStrip);
              hcTrk->Fill(polarity*clustersCharge[j]);
	      //Double_t snr = polarity*clustersCharge[j]/noise[ichan];
	      //hSNR->Fill(y_trk,x_trk,snr);
	      //hSNR->
              if(clustersSize[j]==1) hcTrkCorr->Fill(polarity*clustersCharge[j]);
              if(clustersSize[j]==2 && iPeak==1) hcTrkCorr->Fill(polarity*clustersCharge[j]*(1.0-chargeCorrSlopeOdd));
              if(clustersSize[j]==2 && iPeak==0) hcTrkCorr->Fill(polarity*clustersCharge[j]*(1.0-chargeCorrSlopeEven));
              hcTrkSeed->Fill(polarity*clustersSeedCharge[j]);
              if(clustersSize[j]==1) hcTrkSeed1->Fill(polarity*clustersSeedCharge[j]);
              if(clustersSize[j]==2) hcTrkSeed2->Fill(polarity*clustersSeedCharge[j]);
              if(y_trk - yMax < 5.0) hcTrkNoTop->Fill(polarity*clustersCharge[j]);
              if(x_trk < (xMin+xMax)/2.) hcTrkLowX->Fill(polarity*clustersCharge[j]);
              if(x_trk >= (xMin+xMax)/2.) hcTrkHighX->Fill(polarity*clustersCharge[j]);
              int ix = 4*(x_trk - xMin - 0.001) / (xMax-xMin);
              int iy = 4*(y_trk - yMin - 0.001) / (yMax-yMin);
              int ihist = 4*ix + iy;
              hcTrkXY[ihist]->Fill(polarity*clustersCharge[j]);              
              //if(y_trk>yMin && y_trk<=(yMin+0.25*yRange)) hcTrkY1->Fill(polarity*clustersCharge[j]);
              //if(y_trk>(yMin+0.25*yRange) && y_trk<(yMin+0.50*yRange)) hcTrkY2->Fill(polarity*clustersCharge[j]);
              //if(y_trk>(yMin+0.50*yRange) && y_trk<(yMin+0.75*yRange)) hcTrkY3->Fill(polarity*clustersCharge[j]);
              //if(y_trk>(yMin+0.75*yRange) && y_trk<(yMin+1.00*yRange)) hcTrkY4->Fill(polarity*clustersCharge[j]);
              //if(y_trk>yMin&&y_trk<yMid+1.0) hcTrkY2->Fill(polarity*clustersCharge[j]);

              if(clustersSize[j]==1) hcTrk1->Fill(polarity*clustersCharge[j]);
              if(clustersSize[j]==2) hcTrk2->Fill(polarity*clustersCharge[j]);
              if(clustersPosition[j]>170  && clustersPosition[j]<190) hcTrka->Fill(polarity*clustersCharge[j]);
              h31a->Fill(x_trk,y_trk);
              h32a->Fill(clustersPosition[j]);
              h33a->Fill(y_trk);
              h33b->Fill(x_trk);
              if(polarity*clustersCharge[j] < 250) {
                h31b->Fill(x_trk,y_trk);
                h32b->Fill(clustersPosition[j]);
                h34->Fill(y_trk);
              }
              double chr = clustersCharge1StripRight[j]*polarity;
              double chl = clustersCharge1StripLeft[j]*polarity;
              double chr2 = clustersCharge2StripRight[j]*polarity;
              double chl2 = clustersCharge2StripLeft[j]*polarity;
              double pch = polarity*clustersSeedCharge[j];
	      double asym = (chl - chr) / (chl + chr);
              int ic = pch/50.;
	      double eta=0;
	      if(dx<0)
		eta=(pch-chr)/(pch+chr);
	      else 
		eta=(chl-pch)/(pch+chl);
	      hEta->Fill(clustersSeedPosition[j],eta);
	      hAsym->Fill(clustersSeedPosition[j],asym);
	      hEta_dX->Fill(abs(dx),eta);
              if(ic>=0 && ic<10 && clustersSize[j]<=2 ){
                
                if(iPeak==1) h41[ic]->Fill(chl-chr);
                if(iPeak==0) h42[ic]->Fill(chl-chr);
                if(chr2!=0 and chl2!=0){
                  if(iPeak==1) h43[ic]->Fill(chl2-chr2);
                  if(iPeak==0) h44[ic]->Fill(chl2-chr2);
		}
		
	      } 
	    }
	    
	    double clstrip = getCorrChannel(clustersPosition[j]);
	    h4->Fill(clstrip);
	    h4b->Fill(clstrip + channelOffset);
	    h4a->Fill(clustersPosition[j]);
	    h0->Fill(detStrip - clstrip);
	  }
	}
	
	if(inFiducial && goodTrack && goodTime && foundHitNoFid) {
	  h12on->Fill(distToCutout);
	}

	// for 1D eff except outside fid
	if(goodTrack && goodTime && awayFromCutout) {
	  if(foundHit) {
	    hEffX->Fill(x_trk);
	    hEffY->Fill(y_trk);
	  }
	}
	if(inFiducial && goodTrack && goodTime && awayFromCutout) {
	  h16c->Fill(dtime);
	  if(foundHit) {
	    h3c->Fill(x_trk,y_trk);
	    for(int j=0; j<min(clusterNumberPerEvent,10); j++){
	      hcfpa->Fill(polarity*clustersCharge[j]);
	      if(polarity*clustersCharge[j]>120) h1fpa->Fill(dxh[j]);
	    }        
	    h15c->Fill(dtime);
	    h15b->Fill(clustersTDC+0.1);
	    h15a->Fill(vec_trk_chi2ndf->at(k));
	    h12b->Fill(y_trk);
	    h12dn->Fill(x_trk); 
	    //h_eff_xy->Fill(x_trk,y_trk);
	    
	    if(y_trk>yInt1[0]&&y_trk<yInt1[1]) h12en->Fill(x_trk);
	    if(y_trk>yInt2[0]&&y_trk<yInt2[1]) h12fn->Fill(x_trk);
	    if(y_trk>yInt3[0]&&y_trk<yInt3[1]) h12gn->Fill(x_trk);
	    h12hn->Fill(fracStrip);
	    if(y_trk>yInt1[0]&&y_trk<yInt1[1] && x_trk>-3.5&&x_trk<2.5) h12in->Fill(fracStrip);
	    if(y_trk>yInt2[0]&&y_trk<yInt2[1] && x_trk>-3.5&&x_trk<2.5) h12jn->Fill(fracStrip);
	    if(y_trk>yInt3[0]&&y_trk<yInt3[1] && x_trk>-3.5&&x_trk<2.5) h12kn->Fill(fracStrip);
	    if(y_trk>yInt1[0] && y_trk < yInt2[1] && x_trk>-3.5&&x_trk<-2.0) {
	      h14b->Fill(detStrip);
	      h13fpa->Fill(clusterNumberPerEvent);
	    }else if(y_trk>yInt3[0] && y_trk < yInt3[1]) {
	      h13fbpa->Fill(clusterNumberPerEvent);
	      for(int j=0; j<min(clusterNumberPerEvent,10); j++){
		h1fbpa->Fill(dxh[j]);
		hcfbpa->Fill(polarity*clustersCharge[j]);
	      }
	    }                
	  }else{     
	    h3b->Fill(x_trk,y_trk);          
	    h13mpa->Fill(clusterNumberPerEvent);
	    h16a->Fill(vec_trk_chi2ndf->at(k));
	    h16b->Fill(clustersTDC+0.1);
	    for(int j=0; j<min(clusterNumberPerEvent,10); j++){
	      hcmpa->Fill(polarity*clustersCharge[j]);
	      if(polarity*clustersCharge[j]>120) h1mpa->Fill(dxh[j]);
	    }            
	    nPrint++;
	    if(y_trk>yInt1[0] && y_trk < yInt2[1]) {
	      h14a->Fill(detStrip);
	      if(writeEventsWithMissinhHitsToFile) 
		myfile << jentry << " " << detStrip << " " << x_trk << " " << y_trk << endl;              
	      //if(nPrint < 100) cout << "Missed hit, event, #clu, nomStrip =  " << jentry << " " 
	      //                      << clusterNumberPerEvent << " " << nomStrip << endl;
	      for(int j=0; j<min(clusterNumberPerEvent,10); j++){
		if(x_trk>-3.5&&x_trk<-2.0) h1mpa1->Fill(dxh[j]);
		if(x_trk>-2.0&&x_trk<-1.0) h1mpa2->Fill(dxh[j]);
		if(x_trk>-1.0&&x_trk<0.0) h1mpa3->Fill(dxh[j]);
		if(x_trk>0.0&&x_trk<1.0)  h1mpa4->Fill(dxh[j]);
		if(x_trk>1.5&&x_trk<3.5)  h1mpa5->Fill(dxh[j]);
		if(y_trk<yInt1[1]) h1mpaL->Fill(clustersPosition[j]);                         
		if(y_trk>=yInt1[1]) h1mpaU->Fill(clustersPosition[j]);
	      }
	    }else if(y_trk>yInt3[0] && y_trk < yInt3[1]) {
	      h13mbpa->Fill(clusterNumberPerEvent);
	      for(int j=0; j<min(clusterNumberPerEvent,10); j++){              
		h1mbpa->Fill(dxh[j]);
		hcmbpa->Fill(polarity*clustersCharge[j]);
	      }    
	    }
	  }
	} 
      }
   }
   if(writeEventsWithMissinhHitsToFile) myfile.close();

   int i1 = h1->FindBin(-0.3);
   int i2 = h1->FindBin(0.3);
   cout << "Number of track - DUT hit matchs: " << h1->Integral(i1,i2) << endl;
   cout << "Ry = " << Ry << endl;
   
   
   TString r1 = Form("%6.3f < Y < %6.3f mm",yInt1[0], yInt1[1]);
   TString r2 = Form("%6.3f < Y < %6.3f mm ",yInt2[0], yInt2[1]);
   TString r3 = Form("%6.3f < Y < %6.3f mm",yInt3[0], yInt3[1]);   


   TF1 *funchole = new TF1("funchole","[0]+[1]*x+[2]*x*x",-8.0,8.0);
   funchole->SetParameters(holeQuadPar[0],holeQuadPar[1],holeQuadPar[2]);
   funchole->SetLineColor(4);
   funchole->SetLineWidth(2);
   cout << "Hole Parameters: " << holeQuadPar[0] << " " << holeQuadPar[1] << " " << holeQuadPar[2] << endl;
   
   gStyle->SetOptStat(1000000001);
   gStyle->SetOptFit(0011);
   gStyle->SetStatH(0.05);
   gStyle->SetStatW(0.2);
   gStyle->SetOptStat(0);


   // Get region around beam for given boards (hard coded)
   double lowCh = 0;
   double hiCh = 512;
  /* if(m_board2=="M1" && runplace == "FanIn") {
     lowCh = 445;
     hiCh = 465;
   }
   if(m_board2=="M1" && runplace == "FanUp") {
     lowCh = 188;//lowCh = 161;
     hiCh = 206; //hiCh = 181;
   }
   if(m_board2=="M3" && runplace == "FanIn") {
     lowCh = 434;//lowCh = 412;
     hiCh = 464;//hiCh = 432;
   }
   if(m_board2=="M3" && runplace == "FanUp") {
     lowCh = 190;//lowCh = 163;
     hiCh = 210;//hiCh = 183;
   }
   if(m_board2=="M4" && runplace == "FanIn") {
     lowCh = 443;//lowCh = 431;
     hiCh = 464;//hiCh = 451;
   }
   if(m_board2=="M4" && runplace == "FanUp") {///??????????????????????????????????????????//
     lowCh = 180;//lowCh = 164;
     hiCh = 210;//hiCh = 184;
   }
*/
 /*  if(m_board2=="F1" && runplace == "FanUp") {///??????????????????????????????????????????//
     lowCh = 125;
     hiCh = 220;
   }
   
   if(m_board2=="F3" && runplace == "FanUp") {///??????????????????????????????????????????//
     lowCh = 140;//lowCh = 164;
     hiCh = 485;//hiCh = 184;
   }
   *///   gStyle->SetOptStat(0);

   TCanvas *c_ADCperStrip = addCanvas("c_ADCperStrip");
   addGraphics(hADCperStrip,"channel","ADC","Counts","ADC");
   hADCperStrip->GetXaxis()->SetRangeUser(hADCperStrip->FindFirstBinAbove()-10,hADCperStrip->FindLastBinAbove()+10);
   hADCperStrip->Draw("colz");
   savePlots(c_ADCperStrip,"ADC_per_Strip");
   
   TCanvas *c_SNRperStrip = addCanvas("c_SNRperStrip");
   addGraphics(hSNRperStrip,"channel","SNR","Counts","SNR");
   hSNRperStrip->GetXaxis()->SetRangeUser(hSNRperStrip->FindFirstBinAbove()-10,hSNRperStrip->FindLastBinAbove()+10);
   hSNRperStrip->Draw("colz");
   savePlots(c_SNRperStrip,"SNR_per_Strip");


   vector <Double_t>  SignalMPVpCh;
   vector <Double_t>  SignalMPVpChErr;
   
   vector <Double_t>  MPVpCh;
   vector <Double_t>  MPVpChErr;
   vector <Double_t>  channelNMPV;
   TCanvas *c_SNR_MPVperStrip = addCanvas("c_SNR_MPVperStrip");
   RetVal MPV_perStrip;
   RetVal SignalMPV_perStr;
   for(Int_t iStr=lowCh;iStr<hiCh;iStr++)
   {
     TH1D *hSNR_MPV_strip = new TH1D("SNR_MPV_perStr","SNR_MPV_perStr",50,0,100.);
     TH1D *hSignal_MPV_strip = new TH1D("Signal_MPV_perStr","SNR_Signal_perStr",500,0,1000.);
     for(Int_t j=0;j<hSNR_MPV_strip->GetNbinsX();j++)
     {
       hSNR_MPV_strip->SetBinContent(j+1,hSNRperStrip->GetBinContent(iStr+1,j+1));       
     }
     
     for(Int_t j=0;j<hSignal_MPV_strip->GetNbinsX();j++)
     {
       hSignal_MPV_strip->SetBinContent(j+1,hADCperStrip->GetBinContent(iStr+1,j+1));
     }

     
     
     MPV_perStrip = lFit(hSNR_MPV_strip,1);
     SignalMPV_perStr = lFit(hSignal_MPV_strip,1);
     if(MPV_perStrip.MPV>0){
     MPVpCh.push_back(MPV_perStrip.MPV);
     MPVpChErr.push_back(MPV_perStrip.width);}
     if(SignalMPV_perStr.MPV>0){
       channelNMPV.push_back(iStr);
     SignalMPVpCh.push_back(SignalMPV_perStr.MPV);
     SignalMPVpChErr.push_back(SignalMPV_perStr.width);}
     
    // channelNMPV.push_back(iStr);
     hSNR_MPV_strip->Delete();
     hSignal_MPV_strip->Delete();
   }
   TGraphErrors *gMPVstrip = new TGraphErrors(channelNMPV.size(), &channelNMPV[0],&MPVpCh[0],0,&MPVpChErr[0]);
   addGraphics(gMPVstrip,"Channel","SNR_{MPV}","SNR per Strip");
   gMPVstrip->Draw("AP");
   
   TCanvas *c_signal_MPVperStrip = addCanvas("c_signal_MPVperStrip");
   TGraphErrors *gSigMPVstrip = new TGraphErrors(channelNMPV.size(), &channelNMPV[0],&SignalMPVpCh[0],0,&SignalMPVpChErr[0]);
   addGraphics(gSigMPVstrip,"Channel","Signal_{MPV}","MPV of signal per Strip");
   gSigMPVstrip->Draw("AP");
   
   savePlots(c_signal_MPVperStrip,"Signal_MPV_perStrip");
   savePlots(c_SNR_MPVperStrip,"SNR_MPV_perStrip");
   
   TCanvas *c_ClusterSize_perStrip = addCanvas("c_ClusterSize_perStrip");
   addGraphics(hClusterStrip,"channel","Cluster Size","Cluster Size");
   hClusterStrip->GetXaxis()->SetRangeUser(hClusterStrip->FindFirstBinAbove()-10,hClusterStrip->FindLastBinAbove()+10);
   hClusterStrip->Draw("colz");
   savePlots(c_ClusterSize_perStrip,"ClusterSize_per_Strip");
      
   // loop to normalize
  Double_t maxS=0;
  for (int i=0;i<512;i++){
    maxS=hAlpha->GetBinContent(i,i);
    for(int j=0;j<512;j++){
      if(hAlpha->GetBinContent(i,j)==0) continue;
      hAlpha->SetBinContent(i,j,hAlpha->GetBinContent(i,j)/maxS);
    }
   }
   
   TCanvas *c_alpha = addCanvas("c_alpha");
   addGraphics(hAlpha,"Channel_{seed}", "Channel_{i}","SNR_{i} / SNR_{seed}","SNR_{i} / SNR_{seed}");
   hAlpha->GetXaxis()->SetRangeUser(hAlpha->FindFirstBinAbove()-10,hAlpha->FindLastBinAbove()+10);
   hAlpha->GetYaxis()->SetRangeUser(hAlpha->FindFirstBinAbove(0,2)-10,hAlpha->FindLastBinAbove(0,2)+10);
   hAlpha->GetZaxis()->SetRangeUser(0,.3);
   hAlpha->Draw("colz");
   savePlots(c_alpha,"Alpha");
   
   // Canvas for eta distribution
   // TCanvas *c_eta = new TCanvas("c_eta", "",500,500);
   hEta_proj = hEta->ProjectionY();
   //c_eta->Divide(3);
   TCanvas *c_eta_strip = addCanvas("c_eta_strip");
   addGraphics(hEta, "Channel","#eta","Counts","#eta vs. strip");
   hEta->GetXaxis()->SetRangeUser(hEta->FindFirstBinAbove()-10,hEta->FindLastBinAbove()+10);
   hEta->Draw("colz");
   savePlots(c_eta_strip,"Eta_strip");
  
   TCanvas *c_asym = addCanvas("c_asym");
   addGraphics(hAsym, "Channel","Asymmetry","Counts");
   hAsym->GetXaxis()->SetRangeUser(hAsym->FindFirstBinAbove()-10,hAsym->FindLastBinAbove()+10);
   hAsym->GetZaxis()->SetRangeUser(0,200);
   hAsym->Draw("colz");
   savePlots(c_asym,"Asym_strip");
   
   RetVal averageAsymmperCh;
   vector <Double_t>  averageAsym;
   vector <Double_t>  averageAsymAbs;
   vector <Double_t>  averageAsymEr;
   vector <Double_t>  averageAsymAbsEr;
   vector <Double_t>  channelN;
   for(Int_t iStr=hAsym->FindFirstBinAbove();iStr<hAsym->FindLastBinAbove()+1;iStr++)
   { 
     TH1F *hAsymStr = new TH1F("asymPerStrip","asymPerStrip",200,-1.,1.);
     TH1F *hAsymStrAbs = new TH1F("asymPerStripAbs","asymPerStripAbs",200,-1.,1.);    
     for(Int_t j=0;j<hAsymStr->GetNbinsX();j++)
     {
       hAsymStr->SetBinContent(j, hAsym->GetBinContent(iStr,j+1));  
       if(j<100){hAsymStrAbs->SetBinContent(j+100, hAsym->GetBinContent(iStr,j+1));}
       else{hAsymStrAbs->SetBinContent(j+1, hAsym->GetBinContent(iStr,j+1));}
     }
     
     channelN.push_back(iStr);
     averageAsym.push_back(hAsymStr->GetMean());
     averageAsymEr.push_back(hAsymStr->GetMeanError());
     
     averageAsymAbs.push_back(hAsymStrAbs->GetMean());
     averageAsymAbsEr.push_back(hAsymStrAbs->GetMeanError());
     
     hAsymStr->Delete();
     

     hAsymStrAbs->Delete();
   }
   TCanvas *c_asym_av = addCanvas("c_asym_av");
   TGraphErrors *gAverageAsym = new TGraphErrors(channelN.size(), &channelN[0],&averageAsym[0],0,&averageAsymEr[0]);
   addGraphics(gAverageAsym,"Channel","Asymmetry","Average asymmetry per strip");
   gAverageAsym->Draw("AP");
   
   TCanvas *c_asym_avAbs = addCanvas("c_asym_avAbs");
   TGraphErrors *gAverageAsymAbs = new TGraphErrors(channelN.size(), &channelN[0],&averageAsymAbs[0],0,&averageAsymAbsEr[0]);
   addGraphics(gAverageAsymAbs,"Channel","Asymmetry","Average absolute asymmetry per strip");
   gAverageAsymAbs->Draw("AP");
   
   savePlots(c_asym_av,"Average_asymmetry");
   savePlots(c_asym_avAbs,"AverageAbsolute_asymmetry");
   
   
   TCanvas *c_eta = addCanvas("c_eta");
   addGraphics(hEta_proj,"#eta","Counts","#eta");
   hEta_proj->Draw();
   savePlots(c_eta,"Eta");

   TCanvas *c_eta_dx = addCanvas("c_eta_dx");
   addGraphics(hEta_dX, "|#Delta x|, mm","#eta","Counts","#eta vs. #Delta x");
   hEta_dX->Draw("colz");
   savePlots(c_eta_dx,"Eta_dx");

   TCanvas *c_eff_2D = addCanvas("c_eff_2D");
   h311a->Divide(h311b);					//IARO: TODO -  I would prefer to have a separate histo (not to overwrite one which we have, because it can lead to confuses at some point). But I was not sure that stuff which are done after are not based on it. Need to check
   addGraphics(h311a, "X_{trk}, mm","Y_{trk}, mm","","Efficiency");
   h311a->GetZaxis()->SetRangeUser(0.9,1);
   h311a->Draw("colz");
   savePlots(c_eff_2D,"Eff_2D");
   
   TCanvas *c_Tracks_2D = addCanvas("c_Tracks_2D");
   addGraphics(h311b, "X_{trk}, mm","Y_{trk}, mm","","Tracks");
   h311b->Draw("colz");
   savePlots(c_Tracks_2D,"Tracks_2D");
   
 ///////-------------------------if need to understand efficiency 
 //  TCanvas *cEffDistrP = new TCanvas("ProfileEffDistr", "",1000,1000);
//   cEffDistrP->Divide(3,4);
   TCanvas* cEffDistrP[10];
   TH1F* effProfY[10];
   TH1F* NTrackY[10];
   TLegend* legProfY[10];
   for(Int_t iX=40;iX<52;iX++){
    TString binNx = NumberToString(iX);
    TString nameD = "ProfileEffDistr_"+binNx;
    cEffDistrP[iX-40] = new TCanvas(nameD, "",1000,1000);
   // cEffDistrP->cd(iX-39);
    effProfY[iX-40]= new TH1F(nameD,"effProfY",100,-5,5);
    effProfY[iX-40]->SetTitle("Y distribution of efficiency and Tracks for X bin № "+ binNx);
    effProfY[iX-40]->SetXTitle("Y");
    NTrackY[iX-40]= new TH1F("NTrackY","NTrackY",100,-5,5);
    for(Int_t i=0;i<effProfY[iX-40]->GetNbinsX();i++)
    {
      effProfY[iX-40]->SetBinContent(i+1,h311a->GetBinContent(iX,i+1));
      NTrackY[iX-40]->SetBinContent(i+1,h311b->GetBinContent(iX,i+1));
    }
    effProfY[iX-40]->SetFillColor(3);
    effProfY[iX-40]->Draw();
    //cEffDistrP->cd(2);
    //NTrackY->Draw();
    NTrackY[iX-40]->Scale(1./(NTrackY[iX-40]->GetBinContent(NTrackY[iX-40]->GetMaximumBin())));
    //cEffDistrP->cd(3);
    NTrackY[iX-40]->SetLineColor(2);
    NTrackY[iX-40]->SetLineWidth(2);
    NTrackY[iX-40]->Draw("same");
    legProfY[iX-40] = new TLegend(0.1,0.9,0.48,1.);
    legProfY[iX-40]->AddEntry(effProfY[iX-40],"Efficiency distribution for Y at certain X bin","f"); 
    legProfY[iX-40]->AddEntry(NTrackY[iX-40],"Tracks distribution for Y at certain X bin","l");
    legProfY[iX-40]->Draw();
    savePlots(cEffDistrP[iX-40],nameD,"EfficiencyProfile");
  }
//   savePlots(cEffDistrP,"EffDistrP");
 //----------------------------------------------------------- 
   
   TCanvas *c_eff_X = addCanvas("c_eff_X");
   TH1F *hex = (TH1F*)h12dn->Clone("hex");
   hex->SetName("hex");
   hex->Divide(h12dn,h12dd,1.0,1.0,"B");
   float bw = 1000*h12dd->GetBinWidth(1);
   TString yt = Form("#Good DUT hit / #Track ",bw);
   addGraphics(hex, "X_{trk}, mm", yt,"DUT Efficiency vs. X_{trk}");
   hex->GetXaxis()->SetRangeUser(xMin-0.5,xMax+0.5);
   hex->GetYaxis()->SetRangeUser(0.95,1.02);
   hex->SetMinimum(0.95);
   hex->SetMaximum(1.02);
   hex->Draw("e");
   savePlots(c_eff_X,"Eff_X");
  
   TCanvas *c_eff_Y = addCanvas("c_eff_Y");
   TH1F *hey = (TH1F*)h12b->Clone("hey");
   hey->Divide(h12b,h12a,1.0,1.0,"B");
   //float 
   bw = 1000*h12b->GetBinWidth(1);
   //TString 
   yt = Form("#Good DUT hit / #Track" ,bw);
   addGraphics(hey, "Y_{trk}, mm", yt,"DUT Efficiency vs. Y_{trk}");
   hey->GetXaxis()->SetRangeUser(yMin-0.5,yMax+0.5);
   hey->GetYaxis()->SetRangeUser(0.95,1.02);
   hey->SetMinimum(0.95);
   hey->SetMaximum(1.02);
   hey->Draw("e");
   savePlots(c_eff_Y,"Eff_Y"); 
   

  /* TCanvas *c_snr_2D = addCanvas("c_snr_2D");
   addGraphics(hSNR2D, "X_{trk}, mm","Y_{trk}, mm", "SNR", "SNR");
   hSNR->GetZaxis()->SetRangeUser(0,100);
   hSNR2D->GetZaxis()->SetRangeUser(0,35);
   RetVal value;
   for(int i=0; i< hSNR->GetNbinsX(); i++) {
     
     for(int j=0; j<hSNR->GetNbinsY(); j++) {
       
       if(((i)*(j))%500==1) cout << "gone through " << i*j << " bins" << endl;
       value = lFit(hSNR->ProjectionZ("testH",i,i,j,j),1);
       
       hSNR2D->SetBinContent(j+1,i+1,value.MPV);
       hSNR2D->SetBinError(j+1,i+1,value.width);
     }
     
   }
   hSNR2D->Draw("colz");
   savePlots(c_snr_2D,"SNR_2D");
*/
   TCanvas *c_trk = new TCanvas("c_trk", "",1500,1000);
   c_trk->Divide(3,2);
   c_trk->cd(1)->SetLeftMargin(0.13);;
   gStyle->SetOptStat(0);    
   //h311a->Divide(h311);
   //addGraphics(h311b,1, "X_{trk} [mm]","Y_{trk} [mm]");
   h311b->SetTitle("All Tracks");
   h311b->GetXaxis()->SetTitle("X_{trk} [mm]");
   h311b->GetYaxis()->SetTitle("Y_{trk} [mm]");
   //addGraphics(h4, 1, "Strip # with cluster", "");
   //addGraphics(h4a, 2, "Strip # with cluster", "");
   //h311b->GetXaxis()->SetRangeUser(-4,4);
   //h311b->GetYaxis()->SetRangeUser(-4,4);
   //h311->GetZaxis()->SetRangeUser(0,1);
   h311b->Draw("colz");
   //   if(holeQuadPar[0]!=0) funchole->Draw("same");
   //if(fabs(xLeftHole)<900 && fabs(xRightHole)<900){
   //  TBox *b1 = new TBox(xMin,yMin,xLeftHole,yMax);
   // TBox *b2 = new TBox(xRightHole,yMin,xMax,yMax);
   //  b1->SetLineColor(kBlue); b1->SetLineWidth(2);b1->SetFillStyle(0);   
   //  b1->Draw();
   //  b2->SetLineColor(kBlue); b2->SetLineWidth(2);b2->SetFillStyle(0);   
   //  b2->Draw();
   //}else{   
   //  TBox *b = new TBox(xMin,yMin,xMax,yMax);
   // b->SetLineColor(kBlue); b->SetLineWidth(2);b->SetFillStyle(0);   
    // b->Draw();
   //}

   c_trk->cd(2)->SetLeftMargin(0.13);;
   //h311a->Divide(h311b);
   addGraphics(h311a,1, "X_{trk} [mm]","Y_{trk} [mm]");
   h311a->SetTitle("Efficiency");
   //addGraphics(h4, 1, "Strip # with cluster", "");
   //addGraphics(h4a, 2, "Strip # with cluster", "");
   h311a->GetXaxis()->SetRangeUser(-5,5);
   h311a->GetYaxis()->SetRangeUser(-6,6);
   h311a->GetZaxis()->SetRangeUser(0.9,1);
   h311a->Draw("colz");
   //  if(holeQuadPar[0]!=0) funchole->Draw("same");
   //if(fabs(xLeftHole)<900 && fabs(xRightHole)<900){
   //  TBox *b1 = new TBox(xMin,yMin,xLeftHole,yMax);
   //  TBox *b2 = new TBox(xRightHole,yMin,xMax,yMax);
   //  b1->SetLineColor(kBlue); b1->SetLineWidth(2);b1->SetFillStyle(0);   
   //  b1->Draw();
   //  b2->SetLineColor(kBlue); b2->SetLineWidth(2);b2->SetFillStyle(0);   
   //  b2->Draw();
   //}else{   
   //  TBox *b = new TBox(xMin,yMin,xMax,yMax);
   //  b->SetLineColor(kBlue); b->SetLineWidth(2);b->SetFillStyle(0);   
   // b->Draw();
   //}

   
   // c->cd(12)->Print("testing.root")
   c_trk->cd(3);
   /*
   hSNR2D->GetXaxis()->SetTitle("X_{trk} [mm]");
   hSNR2D->GetYaxis()->SetTitle("Y_{trk} [mm]");
   addGraphics(hSNR2D,1, "X_{trk} [mm]","Y_{trk} [mm]");

   hSNR->GetZaxis()->SetRangeUser(0,100);
   hSNR2D->GetZaxis()->SetRangeUser(0,35);
   RetVal value;
   
   for(int i=0; i< hSNR->GetNbinsX(); i++) {
     
     for(int j=0; j<hSNR->GetNbinsY(); j++) {
       
       if(((i)*(j))%500==1) cout << "gone through " << i*j << " bins" << endl;
       value = lFit(hSNR->ProjectionZ("testH",i,i,j,j),1);
       
       hSNR2D->SetBinContent(j+1,i+1,value.MPV);
       hSNR2D->SetBinError(j+1,i+1,value.width);
     }
     
   }
   
   hSNR2D->Draw("colz");
*/
   c_trk->cd(4);
   addGraphics(h12n,1,"Interstrip Pos","Cluster Size");
   h12n->SetMinimum(0.5);
   h12n->SetMaximum(2.0);
   h12n->Draw();
   TH1F *hepas1 = (TH1F*)h12hn->Clone("hepas1");
   hepas1->Divide(h12hn,h12hd,1.0,1.0,"B");
   c_trk->cd(5);
   addGraphics(hepas1, 1, "Rel. Strip Pos.", "#Good DUT hit / # Track ");
   //c6->cd(1);
   hepas1->SetMaximum(1.2);
   hepas1->SetMinimum(0.5);
   hepas1->Draw();

   c_trk->cd(6);
   addGraphics(h12m,1,"Interstrip Pos","ADC");
   h12m->SetMinimum(0);
   h12m->SetMaximum(1.2*h12m->GetMaximum());
   h12m->Draw();

   
   //   c_trk->cd(6);
   

   c_trk->Print("Plots/TrkPlot_" + m_board2 + "_" + runplace + "_" + consR +"_"+m_runNumb+".png");
   c_trk->Print("Plots/TrkPlot_" + m_board2 + "_" + runplace + "_" + consR +"_"+m_runNumb+".root");

   TCanvas *c_perform = new TCanvas("c_perform","Performance",1500,1000);
   c_perform->Divide(3,2);
   c_perform->cd(1);
   
   //c_perform->cd(3)->SetLeftMargin(0.13);;
   addGraphics(h2p, 1, "TDC time / 2.5 ns", "<ADC>");
   h2p->Draw();
   TLine *l1e = new TLine(tdcLo,0,tdcLo,h2p->GetMaximum());
   TLine *l2e = new TLine(tdcHi,0,tdcHi,h2p->GetMaximum());
   l1e->SetLineColor(kBlue); l2e->SetLineColor(kBlue); l1e->SetLineWidth(2); l2e->SetLineWidth(2);   
   l1e->Draw(); l2e->Draw();

   c_perform->cd(2);
   hcAll->GetXaxis()->SetTitle("SNR");
   addGraphics(hcAll, 1, "SNR", "Entries");

   lFit(hSNR_1);
   
   hSNR_1->SetLineColor(kBlue);
   
   c_perform->cd(3);
   addGraphics(h12cc, 1, "Cluster Size", "");   
   h12cc->GetYaxis()->SetTitleOffset(1.2);
   h12cc->Draw();

   

   c_perform->cd(4);
   addGraphics(h2, 1, "X_{trk} [mm]", "X_{DUT} [mm]");
   double dM = yMax;
   if(xMax>dM) dM = xMax;
   h2->GetXaxis()->SetRangeUser(-1.0*dM-1,dM+1);
   h2->GetYaxis()->SetRangeUser(-1.0*dM-1,dM+1);
   h2->SetMinimum(1);
   h2->SetTitle(0);
   h2->Draw("colz");
  // langaus(hSNR_1);
   ///lFit(hSNR_1);

   
   c_perform->cd(5);
   //c_align->cd(3)->SetLeftMargin(0.13);;
   addGraphics(h9a, 1, "X^{trk} [mm]", "#DeltaX [mm]");
   h9a->GetXaxis()->SetRangeUser(-4,4);   
   h9a->GetYaxis()->SetRangeUser(-0.1,0.1);
   h9a->SetTitle(0);
   h9a->Draw();
 
   c_perform->cd(6);
   //->SetLeftMargin(0.13);;
   addGraphics(h9, 1, "Y^{trk} [mm]", "#DeltaX [mm]");
   h9->GetXaxis()->SetRangeUser(yMin-1,yMax+1);   
   h9->GetYaxis()->SetRangeUser(-0.1,0.1);
   h9->SetTitle(0);
   h9->Draw();
  
   // c_align->cd(6)->SetLeftMargin(0.13);;
   //addGraphics(h8b, 1, "#theta_{Y}^{trk} [mrad]", "#DeltaX [mm]");
   //h8b->GetXaxis()->SetRangeUser(tyMin-0.1,tyMax+0.1);   
   //h8b->GetYaxis()->SetRangeUser(-0.1,0.1);   
   //h8b->SetTitle(0);
   c_perform->Print("Plots/PerformancePlot_" + m_board2 + "_" + runplace + "_" + consR +"_"+m_runNumb+".png");
   c_perform->Print("Plots/PerformancePlot_" + m_board2 + "_" + runplace + "_" + consR +"_"+m_runNumb+".root");
   
   TCanvas *c_align = new TCanvas("c_align", "alignment plots", 1500,1000);
   c_align->Divide(4,2);
   c_align->cd(1)->SetLeftMargin(0.13);
   addGraphics(h2, 1, "X_{trk} [mm]", "X_{DUT} [mm]");
   //double dM = yMax;
   if(xMax>dM) dM = xMax;
   h2->GetXaxis()->SetRangeUser(-1.0*dM-1,dM+1);
   h2->GetYaxis()->SetRangeUser(-1.0*dM-1,dM+1);
   h2->SetMinimum(1);
   h2->SetTitle(0);
   h2->Draw("colz");

   c_align->cd(2)->SetLeftMargin(0.13);;
   addGraphics(h1, 1, "#DeltaX [mm]", "");
   addGraphics(h1z, 2, "#DeltaX [mm]", "");
   addGraphics(h1a, 3, "#DeltaX [mm]", "");
   addGraphics(h1b, 6, "#DeltaX [mm]", "");
   h1->GetXaxis()->SetRangeUser(-0.3,0.3);
   if(m_board == "A1") h1->GetXaxis()->SetRangeUser(-1.5,1.5);
   h1->SetTitle(0);
   h1->SetMaximum(1.2*h1->GetMaximum());
   h1->Draw();   
   //h1z->Draw("same");
   h1a->Draw("same");
   h1b->Draw("same");
   TLine *l1 = new TLine(-stripPitch/2.,0,-stripPitch/2.,0.5*h1->GetMaximum());
   TLine *l2 = new TLine(stripPitch/2,0,stripPitch/2,0.5*h1->GetMaximum());
   TLine *l1a = new TLine(-dxWin,0,-dxWin,0.5*h1->GetMaximum());
   TLine *l2a = new TLine(dxWin,0,dxWin,0.5*h1->GetMaximum());
   l1->SetLineColor(kRed); l2->SetLineColor(kRed);
   l1a->SetLineColor(kBlue); l2a->SetLineColor(kBlue); l1a->SetLineWidth(2); l2a->SetLineWidth(2);
   l1->Draw(); l2->Draw();
   
   TLegend* legend3 = new TLegend(0.15,0.70,0.40,0.89);
   legend3->SetFillStyle(0);
   legend3->SetBorderSize(0);
   legend3->SetFillStyle(0);
   legend3->SetTextSize(0.045);
   
   legend3->AddEntry(h1,"All","L"); 
   legend3->AddEntry(h1a,"1-strip","L"); 
   legend3->AddEntry(h1b,"2-strip","L"); 
   legend3->Draw();
  
   c_align->cd(3)->SetLeftMargin(0.13);;
   addGraphics(h9a, 1, "X^{trk} [mm]", "#DeltaX [mm]");
   h9a->GetXaxis()->SetRangeUser(-4,4);   
   h9a->GetYaxis()->SetRangeUser(-0.1,0.1);
   h9a->SetTitle(0);
   h9a->Draw();
 
   c_align->cd(4)->SetLeftMargin(0.13);;
   addGraphics(h9, 1, "Y^{trk} [mm]", "#DeltaX [mm]");
   h9->GetXaxis()->SetRangeUser(yMin-1,yMax+1);   
   h9->GetYaxis()->SetRangeUser(-0.1,0.1);
   h9->SetTitle(0);
   h9->Draw();
  
   c_align->cd(5)->SetLeftMargin(0.13);;
   addGraphics(h8, 1, "#theta_{X}^{trk} [mrad]", "#DeltaX [mm]");
   h8->GetXaxis()->SetRangeUser(txMin-0.1,txMax+0.1);   
   h8->GetYaxis()->SetRangeUser(-0.1,0.1);  
   h8->SetTitle(0);
   h8->Draw();

   c_align->cd(6)->SetLeftMargin(0.13);;
   addGraphics(h8b, 1, "#theta_{Y}^{trk} [mrad]", "#DeltaX [mm]");
   h8b->GetXaxis()->SetRangeUser(tyMin-0.1,tyMax+0.1);   
   h8b->GetYaxis()->SetRangeUser(-0.1,0.1);   
   h8b->SetTitle(0);
   h8b->Draw();
   
   //h11a->Draw("same")

   c_align->cd(7)->SetLeftMargin(0.13);;
   addGraphics(h5, 1, "#theta_{X}^{trk} [mrad]", "");
   h5->GetXaxis()->SetRangeUser(txMin-0.1,txMax+0.1);   
   h5->SetTitle(0);
   h5->Draw();
   h5c->SetLineColor(2); h5c->Draw("same");
   TLine *l1b = new TLine(txMin,0,txMin,h5->GetMaximum());
   TLine *l2b = new TLine(txMax,0,txMax,h5->GetMaximum());
   l1b->SetLineColor(kBlue); l2b->SetLineColor(kBlue); l1b->SetLineWidth(2); l2b->SetLineWidth(2);
   l1b->Draw(); l2b->Draw();

   c_align->cd(8)->SetLeftMargin(0.13);
   addGraphics(h6, 1, "#theta_{Y}^{trk} [mrad]", "");
   h6->GetXaxis()->SetRangeUser(tyMin-0.1,tyMax+0.1);   
   h6->SetTitle(0);
   h6->Draw();
   h6c->SetLineColor(2); h6c->Draw("same");
   TLine *l1c = new TLine(tyMin,0,tyMin,h6->GetMaximum());
   TLine *l2c = new TLine(tyMax,0,tyMax,h6->GetMaximum());
   l1c->SetLineColor(kBlue); l2c->SetLineColor(kBlue); l1c->SetLineWidth(2); l2c->SetLineWidth(2);   
   l1c->Draw(); l2c->Draw();

   c_align->Print("Plots/AlignPlot_" + m_board2 + "_" + runplace + "_" + consR +"_"+m_runNumb+".png");
   c_align->Print("Plots/AlignPlot_" + m_board2 + "_" + runplace + "_" + consR +"_"+m_runNumb+".root");
   /*
   TCanvas *c_perform = new TCanvas("c_perform","Performance",1500,1000);
   c_perform->Divide(3,2);

    c_perform->cd(1);
   addGraphics(hnoisePerChannel,1,"noise per channel");
   hnoisePerChannel->Draw();

   //c_perform->cd(1)->SetLeftMargin(0.13);;
   //addGraphics(h12cc, 1, "Cluster Size", "");   
   //h12cc->GetYaxis()->SetTitleOffset(1.2);
   //h12cc->Draw();

   c_perform->cd(2)->SetLeftMargin(0.13);
   hcAll->GetXaxis()->SetTitle("SNR");
   addGraphics(hcAll, 1, "SNR", "Entries");

  // langaus(hSNR_1);
   lFit(hSNR_1);

   hSNR_1->SetLineColor(kBlue); //hSNR_1->SetLineWidth(2);
   
   //c_perform->cd(3)->SetLeftMargin(0.13);;
   //addGraphics(h12cc, 1, "Cluster Size", "Entries");   
   //h12cc->GetYaxis()->SetTitleOffset(1.2);
   //h12cc->Draw();

   c_perform->cd(3)->SetLeftMargin(0.13);;
   addGraphics(h2p, 1, "TDC time / 2.5 ns", "<ADC>");
   h2p->Draw();
   TLine *l1e = new TLine(tdcLo,0,tdcLo,h2p->GetMaximum());
   TLine *l2e = new TLine(tdcHi,0,tdcHi,h2p->GetMaximum());
   l1e->SetLineColor(kBlue); l2e->SetLineColor(kBlue); l1e->SetLineWidth(2); l2e->SetLineWidth(2);   
   l1e->Draw(); l2e->Draw();

   c_perform->cd(4)->SetLeftMargin(0.13);;
   gStyle->SetOptStat(0);    
    //h311a->Divide(h311);
//addGraphics(h311b,1, "X_{trk} [mm]","Y_{trk} [mm]");
   h311b->SetTitle("All Tracks");
   h311b->GetXaxis()->SetTitle("X_{trk} [mm]");
   h311b->GetYaxis()->SetTitle("Y_{trk} [mm]");
   //addGraphics(h4, 1, "Strip # with cluster", "");
   //addGraphics(h4a, 2, "Strip # with cluster", "");
   //h311b->GetXaxis()->SetRangeUser(-4,4);
   //h311b->GetYaxis()->SetRangeUser(-4,4);
   //h311->GetZaxis()->SetRangeUser(0,1);
   h311b->Draw("colz");
   if(holeQuadPar[0]!=0) funchole->Draw("same");
   if(fabs(xLeftHole)<900 && fabs(xRightHole)<900){
     TBox *b1 = new TBox(xMin,yMin,xLeftHole,yMax);
     TBox *b2 = new TBox(xRightHole,yMin,xMax,yMax);
     b1->SetLineColor(kBlue); b1->SetLineWidth(2);b1->SetFillStyle(0);   
     b1->Draw();
     b2->SetLineColor(kBlue); b2->SetLineWidth(2);b2->SetFillStyle(0);   
     b2->Draw();
   }else{   
     TBox *b = new TBox(xMin,yMin,xMax,yMax);
     b->SetLineColor(kBlue); b->SetLineWidth(2);b->SetFillStyle(0);   
     b->Draw();
   }

   c_perform->cd(5)->SetLeftMargin(0.13);;
   h311a->Divide(h311);
   addGraphics(h311a,1, "X_{trk} [mm]","Y_{trk} [mm]");
   h311a->SetTitle("Efficiency");
   //addGraphics(h4, 1, "Strip # with cluster", "");
   //addGraphics(h4a, 2, "Strip # with cluster", "");
   h311a->GetXaxis()->SetRangeUser(-5,5);
   h311a->GetYaxis()->SetRangeUser(-6,6);
   h311a->GetZaxis()->SetRangeUser(0,1);
   h311a->Draw("colz");
   if(holeQuadPar[0]!=0) funchole->Draw("same");
   if(fabs(xLeftHole)<900 && fabs(xRightHole)<900){
     TBox *b1 = new TBox(xMin,yMin,xLeftHole,yMax);
     TBox *b2 = new TBox(xRightHole,yMin,xMax,yMax);
     b1->SetLineColor(kBlue); b1->SetLineWidth(2);b1->SetFillStyle(0);   
     b1->Draw();
     b2->SetLineColor(kBlue); b2->SetLineWidth(2);b2->SetFillStyle(0);   
     b2->Draw();
   }else{   
     TBox *b = new TBox(xMin,yMin,xMax,yMax);
     b->SetLineColor(kBlue); b->SetLineWidth(2);b->SetFillStyle(0);   
     b->Draw();
   }

   
   // c->cd(12)->Print("testing.root");
   
   

   c_perform->cd(6);
   hSNR2D->GetXaxis()->SetTitle("X_{trk} [mm]");
   hSNR2D->GetYaxis()->SetTitle("Y_{trk} [mm]");
   addGraphics(hSNR2D,1, "X_{trk} [mm]","Y_{trk} [mm]");

   hSNR->GetZaxis()->SetRangeUser(0,100);
   hSNR2D->GetZaxis()->SetRangeUser(0,100);
   RetVal value;
   for(int i=0; i< hSNR->GetNbinsX(); i++) {
     
     for(int j=0; j<hSNR->GetNbinsY(); j++) {
       
       if(((i+1)*(j+1))%500==1) cout << "gone through " << i*j << " bins" << endl;
       value = lFit(hSNR->ProjectionZ("testH",i,i+1,j,j+1),1);
       
       hSNR2D->SetBinContent(i,j,value.MPV);
       hSNR2D->SetBinError(i,j,value.width);
     }
     
   }
   
   hSNR2D->Draw("colz");
   //hSNR->Project3DProfile("xy")->Draw("colz");

   

   c_perform->Print("Plots/PerformancePlot_" + m_board2 + "_" + runplace + "_" + consR +"_"+m_runNumb+".png");
   c_perform->Print("Plots/PerformancePlot_" + m_board2 + "_" + runplace + "_" + consR +"_"+m_runNumb+".root");
   */
   //TCanvas *c = new TCanvas("c","Residuals",1500,1000);
   //c->Divide(4,3);
   //c->cd(1)->SetLeftMargin(0.13);
   //addGraphics(h2, 1, "X_{trk} [mm]", "X_{DUT} [mm]");
   //double dM = yMax;
   //if(xMax>dM) dM = xMax;
   //h2->GetXaxis()->SetRangeUser(-1.0*dM-1,dM+1);
   //h2->GetYaxis()->SetRangeUser(-1.0*dM-1,dM+1);
   //h2->SetMinimum(1);
   //h2->Draw("colz");
   //
   //c->cd(2)->SetLeftMargin(0.13);;
   //addGraphics(h1, 1, "#DeltaX [mm]", "");
   //addGraphics(h1z, 2, "#DeltaX [mm]", "");
   //addGraphics(h1a, 3, "#DeltaX [mm]", "");
   //addGraphics(h1b, 6, "#DeltaX [mm]", "");
   //h1->GetXaxis()->SetRangeUser(-0.3,0.3);
   //if(m_board == "A1") h1->GetXaxis()->SetRangeUser(-1.5,1.5);
   //h1->SetMaximum(1.2*h1->GetMaximum());
   //h1->Draw();   
   ////h1z->Draw("same");
   //h1a->Draw("same");
   //h1b->Draw("same");
   //TLine *l1 = new TLine(-stripPitch/2.,0,-stripPitch/2.,0.5*h1->GetMaximum());
   //TLine *l2 = new TLine(stripPitch/2,0,stripPitch/2,0.5*h1->GetMaximum());
   //TLine *l1a = new TLine(-dxWin,0,-dxWin,0.5*h1->GetMaximum());
   //TLine *l2a = new TLine(dxWin,0,dxWin,0.5*h1->GetMaximum());
   //l1->SetLineColor(kRed); l2->SetLineColor(kRed);
   //l1a->SetLineColor(kBlue); l2a->SetLineColor(kBlue); l1a->SetLineWidth(2); l2a->SetLineWidth(2);
   //l1->Draw(); l2->Draw();
   ////l1a->Draw(); l2a->Draw();
   //
   //TLegend* legend3 = new TLegend(0.15,0.70,0.40,0.89);
   //legend3->SetFillStyle(0);
   //legend3->SetBorderSize(0);
   //legend3->SetFillStyle(0);
   //legend3->SetTextSize(0.045);
   //
   //legend3->AddEntry(h1,"All","L"); 
   ////legend3->AddEntry(h1z,"ADC < 250","L"); 
   //legend3->AddEntry(h1a,"1-strip","L"); 
   //legend3->AddEntry(h1b,"2-strip","L"); 
   //legend3->Draw();
   //
   //c->cd(3)->SetLeftMargin(0.13);;
   //addGraphics(h8, 1, "#theta_{X}^{trk} [mrad]", "#DeltaX [mm]");
   //h8->GetXaxis()->SetRangeUser(txMin-0.1,txMax+0.1);   
   //h8->GetYaxis()->SetRangeUser(-0.1,0.1);   
   //h8->Draw();
   //c->cd(4)->SetLeftMargin(0.13);;
   //addGraphics(h9, 1, "Y^{trk} [mm]", "#DeltaX [mm]");
   //h9->GetXaxis()->SetRangeUser(yMin-1,yMax+1);   
   //h9->GetYaxis()->SetRangeUser(-0.1,0.1);   
   //h9->Draw();
   //c->cd(5)->SetLeftMargin(0.13);;
   //addGraphics(h9a, 1, "X^{trk} [mm]", "#DeltaX [mm]");
   //h9a->GetXaxis()->SetRangeUser(-4,4);   
   //h9a->GetYaxis()->SetRangeUser(-0.1,0.1);   
   //h9a->Draw();
   //
   ////c->cd(6)->SetLeftMargin(0.13);;
   ////h3c->Divide(h3a);
   ////h122->Divide(h123);
   ////h311a->Divide(h311);
   ////addGraphics(h3c, 1, "X_{trk} [mm]", "Y_{trk} [mm]");
   ////h3c->GetXaxis()->SetRangeUser(xMin-1,xMax+1);   
   ////h3c->GetYaxis()->SetRangeUser(yMin-1,yMax+1);
   ////h3c->GetZaxis()->SetRangeUser(0,1);
   ////h3c->SetTitle("efficiency");   
   ////h3c->Draw("colz");
   //
   ////h3c->GetXaxis()->SetRangeUser(xMin-1,xMax+1);   
   ////h3c->GetYaxis()->SetRangeUser(yMin-1,yMax+1);
   ////h3c->GetZaxis()->SetRangeUser(0,1);
   ////h3c->SetTitle("Efficiency");   
   ////h3c->Draw("colz");
   //// if(holeQuadPar[0]!=0) funchole->Draw("same");
   //// if(fabs(xLeftHole)<900 && fabs(xRightHole)<900){
   ////   TBox *b1 = new TBox(xMin,yMin,xLeftHole,yMax);
   ////   TBox *b2 = new TBox(xRightHole,yMin,xMax,yMax);
   ////   b1->SetLineColor(kBlue); b1->SetLineWidth(2);b1->SetFillStyle(0);   
   ////   b1->Draw();
   ////   b2->SetLineColor(kBlue); b2->SetLineWidth(2);b2->SetFillStyle(0);   
   ////   b2->Draw();
   //// }else{   
   ////   TBox *b = new TBox(xMin,yMin,xMax,yMax);
   ////   b->SetLineColor(kBlue); b->SetLineWidth(2);b->SetFillStyle(0);   
   ////   b->Draw();
   //// }
   //
   //
   //c->cd(7)->SetLeftMargin(0.13);;
   //addGraphics(h5, 1, "#theta_{X}^{trk} [mrad]", "");
   //h5->GetXaxis()->SetRangeUser(txMin-0.1,txMax+0.1);   
   //h5->Draw();
   //h5c->SetLineColor(2); h5c->Draw("same");
   //TLine *l1b = new TLine(txMin,0,txMin,h5->GetMaximum());
   //TLine *l2b = new TLine(txMax,0,txMax,h5->GetMaximum());
   //l1b->SetLineColor(kBlue); l2b->SetLineColor(kBlue); l1b->SetLineWidth(2); l2b->SetLineWidth(2);
   //l1b->Draw(); l2b->Draw();
   //
   //c->cd(8)->SetLeftMargin(0.13);
   //addGraphics(h6, 1, "#theta_{Y}^{trk} [mrad]", "");
   //h6->GetXaxis()->SetRangeUser(tyMin-0.1,tyMax+0.1);   
   //h6->Draw();
   //h6c->SetLineColor(2); h6c->Draw("same");
   //TLine *l1c = new TLine(tyMin,0,tyMin,h6->GetMaximum());
   //TLine *l2c = new TLine(tyMax,0,tyMax,h6->GetMaximum());
   //l1c->SetLineColor(kBlue); l2c->SetLineColor(kBlue); l1c->SetLineWidth(2); l2c->SetLineWidth(2);   
   //l1c->Draw(); l2c->Draw();
   //
   //c->cd(6)->SetLeftMargin(0.13);;
   //h311a->Divide(h311);
   //addGraphics(h311a,1, "X_{trk} [mm]","Y_{trk} [mm]");
   //h311a->SetTitle("Efficiency");
   ////addGraphics(h4, 1, "Strip # with cluster", "");
   ////addGraphics(h4a, 2, "Strip # with cluster", "");
   //h311a->GetXaxis()->SetRangeUser(-5,5);
   //h311a->GetYaxis()->SetRangeUser(-5,5);
   //h311a->GetZaxis()->SetRangeUser(0,1);
   //h311a->Draw("colz");
   //if(holeQuadPar[0]!=0) funchole->Draw("same");
   //if(fabs(xLeftHole)<900 && fabs(xRightHole)<900){
   //  TBox *b1 = new TBox(xMin,yMin,xLeftHole,yMax);
   //  TBox *b2 = new TBox(xRightHole,yMin,xMax,yMax);
   //  b1->SetLineColor(kBlue); b1->SetLineWidth(2);b1->SetFillStyle(0);   
   //  b1->Draw();
   //  b2->SetLineColor(kBlue); b2->SetLineWidth(2);b2->SetFillStyle(0);   
   //  b2->Draw();
   //}else{   
   //  TBox *b = new TBox(xMin,yMin,xMax,yMax);
   //  b->SetLineColor(kBlue); b->SetLineWidth(2);b->SetFillStyle(0);   
   //  b->Draw();
   //}
   ////h11a->Draw("same");
   ////l1d->Draw(); l2d->Draw();
   //
   ////TLegend* legend4 = new TLegend(0.15,0.70,0.94,0.89);
   ////legend4->SetFillStyle(0);
   ////legend4->SetBorderSize(0);
   ////legend4->SetFillStyle(0);
   ////legend4->SetTextSize(0.045);
   ////
   ////legend4->AddEntry(h4,"Sensor strip ch #","L"); 
   ////legend4->AddEntry(h4a,"Electr. ch #","L");
   ////
   ////legend4->Draw();
   //
   //
   //c->cd(9)->SetLeftMargin(0.13);;
   //addGraphics(hcAll, 1, "Cluster charge [ADC]", "Entries");
   //addGraphics(hcTrk1, 3, "Cluster charge [ADC]", "");
   //addGraphics(hcTrk2, 6, "Cluster charge [ADC]", "");
   ////gStyle->SetOptStat(11111);
   ////gStyle->SetOptFit(111);
   //langaus(hcTrk);
   ////hcAll->SetMaximum(1.25*hcAll->GetMaximum());
   ////hcAll->Draw("same");
   //hcTrk->SetLineColor(kBlue); hcTrk->SetLineWidth(2);
   ////hcTrk->Draw("same"); 
   ////langaus(hcTrk);
   //hcTrk1->Draw("same"); 
   //hcTrk2->Draw("same"); 
   //
   //TLegend* legend2 = new TLegend(0.15,0.70,0.94,0.89);
   //legend2->SetFillStyle(0);
   //legend2->SetBorderSize(0);
   //legend2->SetFillStyle(0);
   //legend2->SetTextSize(0.045);
   //
   ////legend2->AddEntry(hcAll,"All clusters, trk in Fid","L"); 
   //legend2->AddEntry(hcTrk,"Clusters w/ tracks","L");
   ////legend2->AddEntry(hcAll,"All clusters","L");
   // legend2->AddEntry(hcTrk1,"1-strip Clusters","L");
   //legend2->AddEntry(hcTrk2,"2-strip Clusters","L");
   //
   //legend2->Draw();
   //
   // c->cd(10)->SetLeftMargin(0.13);;
   //gStyle->SetOptStat(0);    
   // //h311a->Divide(h311);
//a//ddGraphics(h311b,1, "X_{trk} [mm]","Y_{trk} [mm]");
   //h311b->SetTitle("All Tracks");
   //h311b->GetXaxis()->SetTitle("X_{trk} [mm]");
   //h311b->GetYaxis()->SetTitle("Y_{trk} [mm]");
   ////addGraphics(h4, 1, "Strip # with cluster", "");
   ////addGraphics(h4a, 2, "Strip # with cluster", "");
   //h311b->GetXaxis()->SetRangeUser(-5,5);
   //h311b->GetYaxis()->SetRangeUser(-5,5);
   ////h311->GetZaxis()->SetRangeUser(0,1);
   //h311b->Draw("colz");
   //if(holeQuadPar[0]!=0) funchole->Draw("same");
   //if(fabs(xLeftHole)<900 && fabs(xRightHole)<900){
   //  TBox *b1 = new TBox(xMin,yMin,xLeftHole,yMax);
   //  TBox *b2 = new TBox(xRightHole,yMin,xMax,yMax);
   //  b1->SetLineColor(kBlue); b1->SetLineWidth(2);b1->SetFillStyle(0);   
   //  b1->Draw();
   //  b2->SetLineColor(kBlue); b2->SetLineWidth(2);b2->SetFillStyle(0);   
   //  b2->Draw();
   //}else{   
   //  TBox *b = new TBox(xMin,yMin,xMax,yMax);
   //  b->SetLineColor(kBlue); b->SetLineWidth(2);b->SetFillStyle(0);   
   //  b->Draw();
   //}
   //
   //c->cd(11)->SetLeftMargin(0.13);;
   ////addGraphics(h10a, 1, "Strip #", "<ADC>");
   ////addGraphics(h10b, 2, "Strip #", "<ADC>");
   ////addGraphics(h10c, 4, "Strip #", "<ADC>");
   ////int ixl = iLo;
   ////int ixh = iHi;
   ////int yh = hcTrk->GetMean()-50;
   ////h10a->GetXaxis()->SetRangeUser(ixl-2,ixh+2);   
   ////h10a->GetYaxis()->SetRangeUser(yh-200,yh+300);
   ///*
   //h10a->Draw();
   //h10b->SetLineColor(2);h10b->SetMarkerColor(2);
   //h10b->Draw("same");
   //h10c->SetLineColor(4);h10c->SetMarkerColor(4);
   //h10c->Draw("same");
   //
   //TLegend* legend1 = new TLegend(0.25,0.75,0.94,0.89);
   //legend1->SetFillStyle(0);
   //legend1->SetBorderSize(0);
   //legend1->SetFillStyle(0);
   //legend1->SetTextSize(0.045);
   //
   //legend1->AddEntry(h10a,"Top half in Y","LEP"); 
   //legend1->AddEntry(h10b,"Bottom half in Y","LEP"); 
   //legend1->AddEntry(h10c,"Top 2 mm in Y","LEP"); 
   //legend1->Draw();
   //*/
   //addGraphics(h12cc, 1, "Cluster Size", "Entries");   
   //h12cc->GetYaxis()->SetTitleOffset(1.2);
   //h12cc->Draw();
   //
   //c->cd(12)->SetLeftMargin(0.13);;
   //addGraphics(h2p, 1, "TDC time / 2.5 ns", "<ADC>");
   //h2p->Draw();
   //TLine *l1e = new TLine(tdcLo,0,tdcLo,h2p->GetMaximum());
   //TLine *l2e = new TLine(tdcHi,0,tdcHi,h2p->GetMaximum());
   //l1e->SetLineColor(kBlue); l2e->SetLineColor(kBlue); l1e->SetLineWidth(2); l2e->SetLineWidth(2);   
   //l1e->Draw(); l2e->Draw();
   //// c->cd(12)->Print("testing.root");

  //c->Print("Plots/plot_" + m_board2 + "_" + runplace + "_" + consR +"_"+m_runNumb+".png");
  //c->Print("Plots/plot_" + m_board2 + "_" + runplace + "_" + consR +"_"+m_runNumb+".root");

   //return;
 TCanvas *c44 = new TCanvas("c44","Plot 4",800,600);
   addGraphics(h2p, 1, "TDC time / 2.5 ns", "<ADC>");
   h2p->Draw();
   TLine *l1e2 = new TLine(tdcLo,0,tdcLo,h2p->GetMaximum());
   TLine *l2e2 = new TLine(tdcHi,0,tdcHi,h2p->GetMaximum());
   l1e2->SetLineColor(kBlue); l2e2->SetLineColor(kBlue); l1e2->SetLineWidth(2); l2e2->SetLineWidth(2);   
   l1e2->Draw("same"); l2e2->Draw("same");
   //c44->SaveAs("testing.root");

   TCanvas *c4 = new TCanvas("c4","Plot 4",800,600);
   c4->Divide(2,2);
   c4->cd(1)->SetLeftMargin(0.13);
   addGraphics(h12en, 1, "X_{trk} [mm]", "");
   addGraphics(h12fn, 1, "X_{trk} [mm]", "");

   TH1F *hepa1 = (TH1F*)h12en->Clone("hepa1");
   TH1F *hepa2 = (TH1F*)h12fn->Clone("hepa2");
   TH1F *henpa = (TH1F*)h12gn->Clone("henpa");
   hepa1->Divide(h12en,h12ed,1.0,1.0,"B");
   hepa2->Divide(h12fn,h12fd,1.0,1.0,"B");
   henpa->Divide(h12gn,h12gd,1.0,1.0,"B");
   addGraphics(hepa1, 1, "X_{trk} [mm]", "#Good DUT hit / # Track ");
   addGraphics(hepa2, 1, "X_{trk} [mm]", "#Good DUT hit / # Track ");
   h3b->GetYaxis()->SetRangeUser(-5,5);
   h3b->Draw();

   c4->cd(2)->SetLeftMargin(0.13);
   hepa1->GetXaxis()->SetRangeUser(xMin-0.5,xMax+0.5);
   hepa1->SetMinimum(0.0);
   hepa1->SetMaximum(1.2);
   hepa1->SetLineWidth(1);
   hepa1->SetTitle(r1);
   hepa1->Draw("hist");
   c4->cd(3)->SetLeftMargin(0.13);
   hepa2->GetXaxis()->SetRangeUser(xMin-0.5,xMax+0.5);
   hepa2->SetMinimum(0.0);
   hepa2->SetMaximum(1.2);
   hepa2->SetLineWidth(1);
   hepa2->SetTitle(r2);
   hepa2->Draw("hist");

   c4->cd(4)->SetLeftMargin(0.13);
   addGraphics(henpa, 1, "X_{trk} [mm]", "#Good DUT hit / # Track ");
   henpa->GetXaxis()->SetRangeUser(xMin-0.5,xMax+0.5);
   henpa->SetMinimum(0.0);
   henpa->SetMaximum(1.2);
   henpa->SetLineWidth(1);
   henpa->SetTitle(r3);
   henpa->Draw("hist");   


   TCanvas *c5 = new TCanvas("c5","Plot 5",800,600);
   c5->Divide(2,2);
   c5->cd(1)->SetLeftMargin(0.13);
   addGraphics(h12hn, 1, "Rel. Strip Pos", "");
   addGraphics(h12in, 1, "Rel. Strip Pos", "");
   addGraphics(h12jn, 1, "Rel. Strip Pos", "");
   addGraphics(h12kn, 1, "Rel. Strip Pos", "");

   //TH1F *hepas1 = (TH1F*)h12hn->Clone("hepas1");
   TH1F *hepas2 = (TH1F*)h12in->Clone("hepas2");
   TH1F *hepas3 = (TH1F*)h12jn->Clone("hepas3");
   TH1F *hepas4 = (TH1F*)h12kn->Clone("hepas4");
   //hepas1->Divide(h12hn,h12hd,1.0,1.0,"B");
   hepas2->Divide(h12in,h12id,1.0,1.0,"B");
   hepas3->Divide(h12jn,h12jd,1.0,1.0,"B");
   hepas4->Divide(h12kn,h12kd,1.0,1.0,"B");
   addGraphics(hepas1, 1, "Rel. Strip Pos.", "#Good DUT hit / # Track ");
   addGraphics(hepas2, 1, "Rel. Strip Pos.", "#Good DUT hit / # Track ");
   addGraphics(hepas3, 1, "Rel. Strip Pos.", "#Good DUT hit / # Track ");
   addGraphics(hepas4, 1, "Rel. Strip Pos.", "#Good DUT hit / # Track ");
   hepas1->SetTitle("Full Beam Spot");
   hepas1->SetMinimum(0.8);
   hepas1->SetMaximum(1.2);
   hepas1->SetLineWidth(1);
   hepas1->Draw("hist");
   c5->cd(2)->SetLeftMargin(0.13);
   hepas2->SetTitle(r1);
   hepas2->SetMinimum(0.8);
   hepas2->SetMaximum(1.2);
   hepas2->SetLineWidth(1);
   hepas2->Draw("hist");
   c5->cd(3)->SetLeftMargin(0.13);
   hepas3->SetTitle(r2);
   hepas3->SetMinimum(0.8);
   hepas3->SetMaximum(1.2);
   hepas3->SetLineWidth(1);
   hepas3->Draw("hist");
   c5->cd(4)->SetLeftMargin(0.13);
   hepas4->SetTitle(r3);
   hepas4->SetMinimum(0.8);
   hepas4->SetMaximum(1.2);
   hepas4->SetLineWidth(1);
   hepas4->Draw("hist");

  c5->Print("Plots/plot5_" + m_board2 + "_" + runplace + "_" + consR +"_"+m_runNumb+".png");
   c5->Print("Plots/plot5_" + m_board2 + "_" + runplace + "_" + consR +"_"+m_runNumb+".root");
   //return
   

    TCanvas *c1 = new TCanvas("c1","Plot 1",1600,800);
    c1->Divide(3,2);

    c1->cd(1)->SetLeftMargin(0.13);
    addGraphics(h10d, 2, "Y_{trk} [mm]", "<ADC>");
    h10d->GetXaxis()->SetRangeUser(yMin-0.5,yMax+0.5);
    h10d->Draw();

    //c1->cd(2)->SetLeftMargin(0.13);
    //h3b->Draw();   

    c1->cd(2)->SetLeftMargin(0.13);
    addGraphics(h12b, 2, "Y_{trk} [mm]", "");
    addGraphics(h12a, 1, "Y_{trk} [mm]", "");
    h12a->SetMaximum(1.2*h12a->GetMaximum());
    h12a->GetXaxis()->SetRangeUser(yMin-0.5,yMax+0.5);
    h12a->Draw("hist");
    h12b->Draw("hist,same");

    TLegend* legend0 = new TLegend(0.15,0.75,0.94,0.89);
    legend0->SetFillStyle(0);
    legend0->SetBorderSize(0);
    legend0->SetFillStyle(0);
    legend0->SetTextSize(0.045);   
    legend0->AddEntry(h12a,"Track Y pos","LEP"); 
    legend0->AddEntry(h12b,"Track Y pos with good cluster","LEP");
    legend0->Draw();

    c1->cd(3)->SetLeftMargin(0.13);
    TH1F *he = (TH1F*)h12b->Clone("he");
    he->Divide(h12b,h12a,1.0,1.0,"B");
    //float 
    bw = 1000*h12b->GetBinWidth(1);
    //TString 
    yt = Form("#Good DUT hit / # Track" ,bw);
    addGraphics(he, 1, "Y_{trk} [mm]", yt);
    he->SetTitle("DUT Efficiency vs Y_{trk}");
    he->GetXaxis()->SetRangeUser(yMin-0.5,yMax+0.5);
    he->SetMinimum(0.8);
    he->SetMaximum(1.1);
    he->Draw("e");

    c1->cd(4)->SetLeftMargin(0.13);
    addGraphics(h10e, 2, "X_{trk} [mm]", "<ADC>");
    h10e->GetXaxis()->SetRangeUser(xMin-0.5,xMax+0.5);
    h10e->Draw();

    c1->cd(5)->SetLeftMargin(0.13);
    addGraphics(h12dd, 2, "X_{trk} [mm]", "");
    addGraphics(h12dn, 1, "X_{trk} [mm]", "");
    h12dd->SetMaximum(1.2*h12dd->GetMaximum());
    h12dd->GetXaxis()->SetRangeUser(xMin-0.5,xMax+0.5);
    h12dd->Draw("hist");
    h12dn->Draw("hist,same");

    c1->cd(6)->SetLeftMargin(0.13);
    TH1F *he2 = (TH1F*)h12dn->Clone("he");
    he2->SetName("he2");
    he2->Divide(h12dn,h12dd,1.0,1.0,"B");
    bw = 1000*h12dd->GetBinWidth(1);
    yt = Form("(#Good DUT hit / # Track) / %3.0f #mum",bw);
    addGraphics(he2, 1, "X_{trk} [mm]", yt);
    he2->SetTitle("DUT Efficiency vs X_{trk}");
    he2->GetXaxis()->SetRangeUser(xMin-0.5,xMax+0.5);
    he2->SetMinimum(0.8);
    he2->SetMaximum(1.1);
    he2->Draw("e");
    c1->Print("Plots/plot1_" + m_board2 + "_" + runplace + "_" + consR +"_"+m_runNumb+".png");
    c1->Print("Plots/plot1_" + m_board2 + "_" + runplace + "_" + consR +"_"+m_runNumb+".root");

    TCanvas *c8 = new TCanvas("c8","Plot 8",800,400);
    c8->Divide(2,1);
    TH1F *he4 = (TH1F*)h15c->Clone("Eff_trigger-DUT_time");
    he4->Divide(h15c,h16c,1.0,1.0,"B");
    yt = "#Good DUT hit / # Track";
    addGraphics(h16c, 1, "DUT time - Track Time (ns)", "Entries");
    addGraphics(he4, 1, "DUT time - Track Time (ns)", "Efficiency");
    c8->cd(1)->SetLeftMargin(0.15);;
    c8->cd(1)->SetRightMargin(0.05);;
    h16c->Draw();
    c8->cd(2)->SetLeftMargin(0.13);;
    c8->cd(2)->SetRightMargin(0.05);;
    he4->Draw();
    c8->Print("Plots/plot8_" + m_board2 + "_" + runplace + "_" + consR +"_"+m_runNumb+".png");
    c8->Print("Plots/plot8_" + m_board2 + "_" + runplace + "_" + consR +"_"+m_runNumb+".root");   

    if(holeSector){
        TCanvas *c7 = new TCanvas("c7","Plot 7",800,800);
        c7->SetLeftMargin(0.13);
        TH1F *he3 = (TH1F*)h12on->Clone("Erf()_fit");
        he3->Divide(h12on,h12od,1.0,1.0,"B");
        bw = 1000*h12od->GetBinWidth(1);
        yt = Form("(#Good DUT hit / # Track) / %3.0f #mum",bw);
        addGraphics(he3, 1, "Dist to cutout [mm]", yt);
        he3->SetStats(kTRUE);
        he3->SetTitle("DUT Efficiency vs Dist to Cutout");
        he3->GetXaxis()->SetRangeUser(-0.2,2.0);
        he3->GetYaxis()->SetRangeUser(0.0,1.3);
        he3->Draw("e");
        TLatex *myLatex = new TLatex();
        myLatex->SetTextFont(42); myLatex->SetTextColor(1); 
        myLatex->SetTextAlign(12); myLatex->SetNDC(kTRUE); myLatex->SetTextSize(0.047);
        TString text = "Sector "+m_sector;
        c7->cd();
        myLatex->DrawLatex(0.18,0.8,text);

        TF1 *f4a = new TF1("f4a","0.5*[0]*(1+TMath::Erf((x-[1])/[2]))",-0.1,2.0);
        f4a->SetParameters(0.5,0.0,0.04);
        f4a->SetParNames("Const","Mean","Sigma");
        he3->Fit("f4a","R");
        TPad *inset = new TPad("inset","y vx x",0.44,0.1,0.89,0.55);
        inset->SetLeftMargin(0.13);
        inset->SetRightMargin(0.05);
        h3->SetTitle("");
        inset->Draw();
        inset->cd();
        h3->Draw();
        h3b->SetMarkerSize(0.2);h3b->SetMarkerStyle(20);h3b->SetMarkerColor(kRed); 
        h3b->Draw("same");
        if(holeQuadPar[0]!=0) funchole->Draw("same");   

        c7->Print("Plots/plot7_" + m_board2 + "_" + runplace + "_" + consR +"_"+m_runNumb+".png");
        c7->Print("Plots/plot7_" + m_board2 + "_" + runplace + "_" + consR +"_"+m_runNumb+".root");   
    }

    /*
       TCanvas *c2 = new TCanvas("c2","Plot 2",1600,600);
       c2->Divide(5,2);
       addGraphics(h1mpa, 2, "X_{clu}-X_{trk} [mm]", ""); h1mpa->SetTitle("2.8<Y_{trk}<4.1 mm, All X, No Match Clu");
       addGraphics(h1mbpa, 4, "X_{clu}-X_{trk} [mm]", ""); h1mbpa->SetTitle("1.0<Y_{trk}<2.3 mm, All X, No Match Clu");
       addGraphics(h1fpa, 1, "X_{clu}-X_{trk} [mm]", ""); h1fpa->SetTitle("2.8<Y_{trk}<4.1 mm, All X, Match Clu");
       addGraphics(h1fbpa, 1, "X_{clu}-X_{trk} [mm]", ""); h1fbpa->SetTitle("1.0<Y_{trk}<2.3 mm, All X, Match Clu");

       addGraphics(h1mpa1, 2, "X_{clu}-X_{trk} [mm]", ""); h1mpa1->SetTitle("2.8<Y_{trk}<4.1 mm, -3.5<X_{trk}<-2.0 mm, No Match Clu");
       addGraphics(h1mpa2, 2, "X_{clu}-X_{trk} [mm]", ""); h1mpa2->SetTitle("2.8<Y_{trk}<4.1 mm, -2.0<X_{trk}<-1.0 mm, No Match Clu");
       addGraphics(h1mpa3, 2, "X_{clu}-X_{trk} [mm]", ""); h1mpa3->SetTitle("2.8<Y_{trk}<4.1 mm, -1.0<X_{trk}<0.0 mm, No Match Clu");
       addGraphics(h1mpa4, 2, "X_{clu}-X_{trk} [mm]", ""); h1mpa4->SetTitle("2.8<Y_{trk}<4.1 mm,  0.0<X_{trk}<1.0 mm, No Match Clu");
       addGraphics(h1mpa5, 2, "X_{clu}-X_{trk} [mm]", ""); h1mpa5->SetTitle("2.8<Y_{trk}<4.1 mm,  1.5<X_{trk}<3.5 mm, No Match Clu");
       h1mpa->SetLineWidth(1); 
       h1mpa1->SetLineWidth(1); 
       h1mpa2->SetLineWidth(1); 
       h1mpa3->SetLineWidth(1); 
       h1mpa4->SetLineWidth(1); 
       h1mpa5->SetLineWidth(1); 
       h1fpa->SetLineWidth(1); 
       h1fbpa->SetLineWidth(1); 


       h1fpa->GetXaxis()->SetRangeUser(-3,9); 
       h1fbpa->GetXaxis()->SetRangeUser(-3,9); 
       h1mbpa->GetXaxis()->SetRangeUser(-3,9); 
       h1mpa->GetXaxis()->SetRangeUser(-3,9); 
       h1mpa1->GetXaxis()->SetRangeUser(-3,9); 
       h1mpa2->GetXaxis()->SetRangeUser(-3,9); 
       h1mpa3->GetXaxis()->SetRangeUser(-3,9); 
       h1mpa4->GetXaxis()->SetRangeUser(-3,9); 
       h1mpa5->GetXaxis()->SetRangeUser(-3,9); 

       c2->cd(1);
       h3b->Draw();   
       double xl[5] = {-3.5, -2.0, -1.0, 0.0, 1.5};
       double xh[5] = {-2.0, -1.0,  0.0, 1.0, 3.5};


       for(int i=0;i<5;i++){
       TBox *b = new TBox(xl[i],yInt1[0],xh[i],yInt2[1]);
       b->SetLineColor(2); b->SetFillStyle(0);b->SetLineWidth(2);
       b->Draw();
       }
       TBox *b = new TBox(xl[0],yInt3[0],xh[4],yInt3[1]);
       b->SetLineColor(4);b->SetFillStyle(0);b->SetLineWidth(2);
       b->Draw();



       c2->cd(2);
       h1mpa->Draw();   
       c2->cd(3);
       h1fpa->GetYaxis()->SetRangeUser(0,30);
       h1fpa->Draw();   
       c2->cd(4);
       h1mbpa->Draw();   
       c2->cd(5);
       h1fbpa->GetYaxis()->SetRangeUser(0,30);
       h1fbpa->Draw();   
       c2->cd(6);   
       h1mpa1->Draw();   
       c2->cd(7);
       h1mpa2->Draw();   
       c2->cd(8);
       h1mpa3->Draw();   
       c2->cd(9);
       h1mpa4->Draw();   
       c2->cd(10);
       h1mpa5->Draw();
       c2->Print("Plots/plot2_"+m_board+"_s"+m_sector+"_vb"+m_bias+".png");
    */

        /*
           TCanvas *c3 = new TCanvas("c3","Plot 3",800,600);
           c3->Divide(1,2);
           c3->cd(1);
           h1mpaU->GetXaxis()->SetRangeUser(iLo-10,iHi+10);
           h1mpaU->Draw();
           c3->cd(2);
           h1mpaL->GetXaxis()->SetRangeUser(iLo-10,iHi+10);
           h1mpaL->Draw();   
           c3->Print("Plots/plot3_"+m_board+"_s"+m_sector+"_vb"+m_bias+".png");
           */

        addGraphics(h12m,1,"Interstrip Pos","ADC");
    addGraphics(h12n,1,"Interstrip Pos","Cluster Size");
    TCanvas *c6 = new TCanvas("c6","Plot 6",1200,400);
    c6->Divide(4,1);
    c6->cd(1);
    hepas1->SetMaximum(1.2);
    hepas1->SetMinimum(0.5);
    hepas1->Draw();
    c6->cd(2);
    h12m->SetMinimum(0);
    h12m->SetMaximum(1.2*h12m->GetMaximum());
    h12m->Draw();
    c6->cd(3);
    h12n->SetMinimum(0.5);
    h12n->SetMaximum(2.0);
    h12n->Draw();

    c6->cd(4)->SetLeftMargin(0.13);;
    addGraphics(h12cc, 1, "Cluster Size", "");   
    h12cc->GetYaxis()->SetTitleOffset(1.2);
    h12cc->Draw();

    c6->Print("Plots/CrossTalk_" + m_board2 + "_" + runplace + "_" + consR +"_"+m_runNumb+".png");
    c6->Print("Plots/CrossTalk_" + m_board2 + "_" + runplace + "_" + consR +"_"+m_runNumb+".root");
    
//---------------------------------------------------------------------------------------------------

   addGraphics(h3b, 1, "X_{trk} [mm]", "Y_{trk} [mm] ");
   h3b->GetXaxis()->SetRangeUser(-5,5);
   h3b->GetYaxis()->SetRangeUser(-5,5);

   TCanvas *c_strip = new TCanvas("c_strip", "",1500,1000);
   c_strip->Divide(3,2);
   c_strip->cd(1);
   addGraphics(hnoisePerChannel,1,"noise per channel");
   hnoisePerChannel->Draw();

   c_strip->cd(2);
  // addGraphics(hADCperStrip, 1 ,"channel","ADC");
   hADCperStrip->GetXaxis()->SetRangeUser(lowCh,hiCh);
   hADCperStrip->Draw("colz");

   c_strip->cd(3);
 //  addGraphics(hSNRperStrip, 1 ,"channel","SNR");
   hSNRperStrip->GetXaxis()->SetRangeUser(lowCh,hiCh);
   hSNRperStrip->Draw("colz");

   c_strip->cd(4);
  // addGraphics(hClusterStrip, 1, "channel","<Cluster Size>");
   hClusterStrip->GetXaxis()->SetRangeUser(lowCh,hiCh);
   hClusterStrip->Draw();

   c_strip->cd(5);
   hEta->GetXaxis()->SetRangeUser(lowCh,hiCh);
   //addGraphics(hEta, 1, "channel", "#eta");
   hEta->Draw("colz");

   c_strip->cd(6);

// loop to normalize
/*  Double_t maxS=0;
  for (int i=0;i<512;i++){
    maxS=hAlpha->GetBinContent(i,i);
    for(int j=0;j<512;j++){
      if(hAlpha->GetBinContent(i,j)==0) continue;
      hAlpha->SetBinContent(i,j,hAlpha->GetBinContent(i,j)/maxS);
    }
  }
   hAlpha->GetZaxis()->SetRangeUser(0,0.2);
   addGraphics(hAlpha,"Channel (seed)", "Channel","SNR","SNR_{i} / SNR_{seed}");
   hAlpha->GetXaxis()->SetRangeUser(lowCh,hiCh);
   hAlpha->GetYaxis()->SetRangeUser(lowCh,hiCh);
  */ hAlpha->Draw("colz");

   c_strip->Print("Plots/StripPlot_" + m_board2 + "_" + runplace + "_" + consR +"_"+m_runNumb+".png");
   c_strip->Print("Plots/StripPlot_" + m_board2 + "_" + runplace + "_" + consR +"_"+m_runNumb+".root");   
   
/*    
   TCanvas *c_snr_2D = addCanvas("c_snr_2D");
   addGraphics(hSNR2D, "X_{trk}, mm","Y_{trk}, mm", "SNR", "SNR");
   hSNR->GetZaxis()->SetRangeUser(0,100);
   hSNR2D->GetZaxis()->SetRangeUser(0,35);
   RetVal value;
   for(int i=0; i< hSNR->GetNbinsX(); i++) {
     
     for(int j=0; j<hSNR->GetNbinsY(); j++) {
       
       if(((i)*(j))%500==1) cout << "gone through " << i*j << " bins" << endl;
       value = lFit(hSNR->ProjectionZ("testH",i,i,j,j),1);
       
       hSNR2D->SetBinContent(j+1,i+1,value.MPV);
       hSNR2D->SetBinError(j+1,i+1,value.width);
     }
     
   }
   hSNR2D->Draw("colz");
   savePlots(c_snr_2D,"SNR_2D");

*/    


    fout->Write();


}
